<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="数据结构,算法,前端,c,c++,程序猿">
    <meta name="description" content="数据结构第一章：数据结构的基本概念定义
数据结构：相互之间存在一种或多种特定关系的数据元素的集合。
数据：描述客观事物的数和字符的集合
数据项：具有独立含义的数据最小单元
数据对象：指性质相同的数据元素的集合，它是数据的一个子集
数据结构包">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>北街学长的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.0.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">北街学长的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>联系</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">北街学长的博客</div>
        <div class="logo-desc">
            
            电子科技大学22级研究生
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			联系
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title"></h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-12-23
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="第一章：数据结构的基本概念"><a href="#第一章：数据结构的基本概念" class="headerlink" title="第一章：数据结构的基本概念"></a>第一章：数据结构的基本概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>数据结构：相互之间存在一种或多种特定关系的数据元素的集合。</li>
<li>数据：描述客观事物的数和字符的集合</li>
<li>数据项：具有独立含义的数据最小单元</li>
<li>数据对象：指性质相同的数据元素的集合，它是数据的一个子集</li>
<li>数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。</li>
</ul>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><ul>
<li>逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的，逻辑结构是为了方面人们进行理解。</li>
<li>数据的逻辑结构分为线性结构和非线性结构<ul>
<li>集合 结构中的数据元素之间除了“同属于一个集合”的关系外，别无其他关系。 类似于数学上的集合</li>
<li>线性结构 结构中的数据元素之间只存在一对一的关系。比如排队</li>
<li>树形结构 结构中的数据元素之间存在一对多的关系。比如家族族谱</li>
<li>图状结构或网状结构 结构中的数据元素之间存在多对多的关系。 比如社交关系网</li>
</ul>
</li>
</ul>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><ul>
<li>存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示，也就是说我不仅要求计算机将每一个数据元素存储到空闲的内存中，还必须得将它们之间的关系表示出来。数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。数据的存储结构主要有：顺序存储、链式存储、索引存储和散列存储。<ul>
<li>顺序存储：存储的物理位置相邻。（p.s. 物理位置即信息在计算机中的位置。）<br>    * 优点：存储效率高，随机存取<br>      * 缺点：不便于数据修改，对元素的插入或删除操作可能需要移动一系列的元素</li>
<li>链接存储：存储的物理位置未必相邻，通过记录相邻元素的物理位置来找到相邻元素。在C语言里面用指针这个东西来指定，后续我们会讲到。<ul>
<li>优点：便于数据修改</li>
<li>缺点：存储空间的利用率低，因为有一部分空间用来存储节点之间的逻辑关系</li>
</ul>
</li>
<li>索引存储：类似于目录，以后可以联系操作系统的文件系统章节来理解。每个数据元素都有一个关键字和对应的存储地址<ul>
<li>优点：查找效率高</li>
<li>缺点：需要建立索引表，增加了空间开销</li>
</ul>
</li>
<li>散列存储：根据元素的关键字通过哈希（散列）函数直接计算出一个值，并将这个值作为该元素的存储地址<ul>
<li>优点：查找速度快</li>
<li>缺点：只负责对元素的存储任务，不负责存储元素之间的逻辑关系</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li>算法是对特定问题求解步骤的一种描述，它是指令的有限序列。大家都知道的一个故事：把大象装进冰箱（特定问题），第一步打开冰箱–第二步把大象塞进去–第三步关闭冰箱门（求解步骤）而整个指令是有限的，这其实就可以算是一个算法了</li>
</ul>
<h3 id="算法的五个特征"><a href="#算法的五个特征" class="headerlink" title="算法的五个特征"></a>算法的五个特征</h3><ul>
<li>1，有穷性：有限步之后结束</li>
<li>2，确定性：不存在二义性，即没有歧义</li>
<li>3，可行性：比如受限于计算机的计算能力，有些算法虽然理论上可行，但实际上无法完成。</li>
<li>4，输入：能被计算机处理的各种类型数据，如数字，音频，图像等等。</li>
<li>5，输出：一至多个程序输出结果。</li>
</ul>
<h3 id="算法设计的目标"><a href="#算法设计的目标" class="headerlink" title="算法设计的目标"></a>算法设计的目标</h3><ul>
<li>1,  正确性:要求算法能够正确地执行预先规定的功能和性能要求，这是最重要也是最基本的要求</li>
<li>2，可使用性：要求算法能够很方便的使用</li>
<li>3，可读性：易于理解</li>
<li>4，健壮性：要求算法具有很好的容错性，别那么脆弱</li>
<li>5，高效率和低存储量要求：简单来说，就是时间复杂度和空间复杂度要较低，其实现实中的很多问题都可以采用暴力算法解决，但是这样会很不友好，所以低时间、空间复杂度一直以来是科学家们所追求的</li>
</ul>
<h3 id="算法的复杂度"><a href="#算法的复杂度" class="headerlink" title="算法的复杂度"></a>算法的复杂度</h3><ul>
<li>时间复杂度：<ul>
<li>• 它用来衡量算法随着问题规模增大，算法执行时间增长的快慢；</li>
<li>• 是问题规模的函数：T(n)是时间规模函数 时间复杂度主要分析T(n)的数量级</li>
<li>• T(n)&#x3D;O(f(n)) f(n)是算法中基本运算的频度 一般我们考虑最坏情况下的时间复杂度</li>
</ul>
</li>
<li>空间复杂度：<ul>
<li>• 它用来衡量算法随着问题规模增大，算法所需空间的快慢；</li>
<li>• 是问题规模的函数：S(n)&#x3D;O(g(n)) ；算法所需空间的增长率和g(n)的增长率相同。</li>
</ul>
</li>
</ul>
<h3 id="概要-复杂度计算为重点（幕布讲解）"><a href="#概要-复杂度计算为重点（幕布讲解）" class="headerlink" title="概要: 复杂度计算为重点（幕布讲解）"></a>概要: 复杂度计算为重点（幕布讲解）</h3><ul>
<li>常用的时间复杂度大小关系：O(n!)&gt;O(2^n)&gt;O(n^3)&gt;O(n^2)&gt;O(nlog2n)&gt;O(n)&gt;O(logn)&gt;O(1)</li>
<li>复杂度如何计算<ul>
<li>时间复杂度计算（单个循环体）<ul>
<li>直接关注循环体的执行次数，设为k</li>
</ul>
</li>
<li>时间复杂度计算（多个循环体）<ul>
<li>两个运算规则：乘法规则，加法规则。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第二章：线性表"><a href="#第二章：线性表" class="headerlink" title="第二章：线性表"></a>第二章：线性表</h2><h3 id="线性表的逻辑结构"><a href="#线性表的逻辑结构" class="headerlink" title="线性表的逻辑结构"></a>线性表的逻辑结构</h3><ul>
<li>定义：线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列。其中n为表长。当n&#x3D;0时 线性表是一个空表</li>
<li>特点：<ol>
<li>有穷性：一个线性表中的元素个数是有限的</li>
<li>一致性：一个线性表中所有元素的性质相同。从实现的角度看，所有元素具有相同的数据类型</li>
<li>序列性：一个线性表中所有元素之间的相对位置是线性的，即存在唯一的开始元素和终端元素。除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外，每个元素有且仅有一个直接后继。</li>
</ol>
</li>
</ul>
<h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h3><ul>
<li>线性表的顺序存储又称为顺序表。  </li>
<li>它是用一组地址连续的存储单元（比如C语言里面的数组），依次存储线性表中的数据元素，从而使得逻<br>辑上相邻的两个元素在物理位置上也相邻。</li>
<li>建立顺序表的三个属性:<br>1.存储空间的起始位置（数组名data）<br>2.顺序表最大存储容量（MaxSize）<br>3.顺序表当前的长度（length）</li>
<li>其实数组还可以动态分配空间，存储数组的空间是在程序执行过程中通过动态存储分配语句分配</li>
<li>总结：<ul>
<li>1.顺序表最主要的特点是随机访问（C语言中基于数组），即通过首地址和元素序号可以在O(1)的时间内找到指定的元素。</li>
<li>2.顺序表的存储密度高，每个结点只存储数据元素。无需给表中元素花费空间建立它们之间的逻辑关系（因为物理位置相邻特性决定）</li>
<li>3.顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。</li>
<li>4.顺序表容易产生内存碎片</li>
</ul>
</li>
</ul>
<h3 id="顺序表的操作"><a href="#顺序表的操作" class="headerlink" title="顺序表的操作"></a>顺序表的操作</h3><ul>
<li><p>1.创建顺序表</p>
<ul>
<li><p>算法思路：</p>
<ul>
<li>1.根据顺序表长度分配空间</li>
<li>2.依次存入数据</li>
</ul>
</li>
<li><p>代码：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">//C语言方式</span></span><br><span class="line">	<span class="type">int</span> data[MAXSIZE];</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SqList</span> &#123;</span><span class="comment">//c++方式，个人推荐这种方式，简单</span></span><br><span class="line">	<span class="type">int</span> data[MAXSIZE];</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line">SqList* <span class="title function_">createList</span><span class="params">(<span class="type">int</span> length)</span> &#123;<span class="comment">//传入要创建的顺序表的长度</span></span><br><span class="line">	SqList* L = (SqList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SqList) * length);<span class="comment">//分配存放线性表的空间</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入第%d个元素&quot;</span>, i);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, L-&gt;data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;length = length;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>分析：</p>
<ul>
<li>时间复杂度：很明显，这里用到了单层循环，时间复杂度为O(n)。</li>
<li>空间复杂度：这里给顺序表分配了空间，规模为n，所以空间复杂度为O(n)。</li>
</ul>
</li>
</ul>
</li>
<li><p>2.查找</p>
<ul>
<li><p>算法思路：</p>
</li>
<li><ol>
<li>从起始元素开始进行遍历</li>
<li>若当前元素即为要查找元素，查找结束，返回当前元素位置</li>
<li>若当前元素非要查找元素，继续向后查找，直至查找成功或到达表尾。</li>
</ol>
</li>
<li><p>代码：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(SqList* L,<span class="type">int</span> n)</span> &#123;<span class="comment">//输入待查找顺序表和待查找元素值，返回待查找元素在顺序表中的下标，若未查找成功，返回-1</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L-&gt;length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (L-&gt;data[i] == n)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>3.删除</p>
<ul>
<li><p>算法思路：</p>
<p>  有两种删除，一种是直接传入要删除元素的下标，另一种是传入要删除元素的值。思路大同小异</p>
<ul>
<li>1.传入下标或元素值从前往后依次进行比较</li>
<li>2.若当前元素为要删除元素（若是下标可直接定位到要删除元素位置）</li>
<li>3.取出当前元素</li>
<li>3.将被删元素后面的所有元素都依次向前移动一位</li>
<li>4.修改表长</li>
</ul>
</li>
<li><p>代码</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(SqList*L,<span class="type">int</span> n)</span> &#123;<span class="comment">//传入顺序表以及待删除的元素值，假设待删除的元素唯一</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L-&gt;length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (L-&gt;data[i]==n) &#123;<span class="comment">//找到</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; L-&gt;length; j++)<span class="comment">//将后续元素往前移动</span></span><br><span class="line">			&#123;</span><br><span class="line">				L-&gt;data[i] = L-&gt;data[i + <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">//因为该值唯一，所以一旦找到并处理后就可以结束程序，也可以写return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;length--;<span class="comment">//将顺序表的长度减一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>分析</p>
<ul>
<li><p>最好情况：删除表尾元素（即i&#x3D;n），无须移动元素，时间复杂度为O(1)。</p>
</li>
<li><p>最坏情况：删除表头元素（即i&#x3D;1），需要移动除第一个元素外的所有元素，时间复杂度为O(n)。</p>
</li>
<li><p>平均情况：假设pi(pi&#x3D;1&#x2F;n)是删除第i个位置上结点的概率，则在长度为n的线性表中删除一个结点时所需移动结点的平均次数为</p>
<p>$ \sum_{i&#x3D;1}^{n}p_i(n-i) &#x3D; \sum_{i&#x3D;1}^{n}\frac{1}{n}{(n-i)} &#x3D; \frac{1}{n} \chi\frac{n(n-1)}{2} &#x3D; \frac{n-1}{2}]$  该算法的主要时间都是花费在元素的移动上，因此删除算法的平均时间复杂度为O(n)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>4.插入</p>
<ul>
<li><p>算法思路：我们要在第i($1\leq i \leq n+1$ )个位置插入新元素e</p>
<ul>
<li>从最后一个元素开始不断往后移动直至第i个元素</li>
<li>腾出的新位置插入新元素</li>
</ul>
</li>
<li><p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">insert</span><span class="params">(SqList*L,<span class="type">int</span> newE,<span class="type">int</span> i)</span> &#123;<span class="comment">//传入顺序表和待插入元素以及插入位置</span></span><br><span class="line">	<span class="keyword">if</span> (i &lt;= <span class="number">0</span> || i &gt;= L-&gt;length + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = L-&gt;length - <span class="number">1</span>; j &gt;= i<span class="number">-1</span>; j--)</span><br><span class="line">	&#123;</span><br><span class="line">		L-&gt;data[j] = L-&gt;data[j + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;data[i - <span class="number">1</span>] = newE;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h3><ul>
<li><p>链表概述:</p>
<ul>
<li><p>顺序表必须占用一整块实现分配大小的存储空间,这样会降低存储空间的利用率,为此有了可以实现存储空间动态管理的链式存储结构-链表</p>
</li>
<li><p>线性表的链式存储是指通过一组任意的存储单元来存储线性表中的数据元素。所谓”链”,其实就是一个标志,用于揭示两个元素之间的逻辑关系.</p>
</li>
<li><p>在C&#x2F;C++语言中,往往采用指针来表示”链”,称之为指针域,而其本身所携带的数据部分称之为数据域</p>
</li>
</ul>
</li>
<li><p>相关术语:</p>
<ul>
<li>头指针:在线性表的链式存储中,通常每个链表带有一个头结点,并通过头结点的指针位置标识该链表,我们将其称之为头指针</li>
<li>首指针:指向首节点(开始节点)的指针</li>
<li>尾指针:指向尾节点的指针</li>
<li>头结点:头结点指的是带头结点的链表中的第一个节点,结点内通常不存储信息,只会有一个指针域,指向首元结点</li>
<li>首元结点:第一个数据域有值的结点</li>
</ul>
</li>
<li><p>为什么要设置头结点？</p>
<ul>
<li>1.处理操作起来方便 例如：对在第一元素结点前插入结点和删除第一结点起操作与其它结点的操作就统一了</li>
<li>2.无论链表是否为空，其头指针是指向头结点的非空指针，因此空表和非空表的处理也就统一了。</li>
</ul>
</li>
<li><p>图示:<img src="/.%5Cimgs%5Cimage-20230615184110154.png" alt="image-20230615184110154"></p>
</li>
<li><p>顺序表与链表对比:</p>
<ul>
<li>顺序表:需要连续的一段存储空间,插入删除元素通常需要平均移动半个表的元素,具有随机存取的特性</li>
<li>链表:不需要连续的存储空间,插入删除元素只需要更改相应结点的指针域即可,不具有随机存取的特性</li>
</ul>
</li>
</ul>
<p>​    </p>
<p>​     </p>
<h3 id="单链表的操作"><a href="#单链表的操作" class="headerlink" title="单链表的操作"></a>单链表的操作</h3><ul>
<li><p>单链表的结构</p>
<ul>
<li>单链表的结构如图所示<img src="/.%5Cimgs%5Cimage-20230615185919208.png" alt="image-20230615185919208"></li>
<li>单链表的结构由两部分构成:data为数据域,用于存放节点本身的信息,next为指针域,里面存放着下一个结点的地址</li>
</ul>
</li>
<li><p>单链表的结构体</p>
<ul>
<li><pre><code class="c++">struct SingleLink&#123;
    int data;//数据域
    SingleLink *next;//指针域
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 单链表的基本操作</span><br><span class="line"></span><br><span class="line">  * 建立单链表</span><br><span class="line">      * 1.头插法建立单链表：</span><br><span class="line"></span><br><span class="line">        * 首先确定要创建的单链表元素个数,进行循环输入结点数值</span><br><span class="line"></span><br><span class="line">        * 每输入一个元素值都要创建一个单链表结点,将链表结点的数据域赋值为输入的值</span><br><span class="line"></span><br><span class="line">        * 将每一次创建的单链表结点s,利用头插法插入到链表头部</span><br><span class="line"></span><br><span class="line">        * 图示![image-20230615192056986](.\imgs\image-20230615192056986.png)</span><br><span class="line"></span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">        * 代码</span><br><span class="line"></span><br><span class="line">          ```c</span><br><span class="line">          //头插法创建单链表</span><br><span class="line">          singleLink* createSingleLink() &#123;</span><br><span class="line">          	int n, data;</span><br><span class="line">          	printf(&quot;请输入创建链表的节点个数：&quot;);</span><br><span class="line">          	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">          	SingleLink* L = (SingleLink*)malloc(sizeof(SingleLink));</span><br><span class="line">          	L-&gt;next = NULL;</span><br><span class="line">          	for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">          		SingleLink* s = (singleLink*)malloc(sizeof(SingleLink));</span><br><span class="line">          		printf(&quot;请输入第%d个节点的值(int)：&quot;, i + 1);</span><br><span class="line">          		scanf(&quot;%d&quot;, &amp;data);</span><br><span class="line">          		s-&gt;data = data;</span><br><span class="line">          		s-&gt;next = NULL;</span><br><span class="line">          		s-&gt;next = L-&gt;next;</span><br><span class="line">          		L-&gt;next = s;</span><br><span class="line">          	&#125;</span><br><span class="line">          	return L;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

      本算法的时间复杂度为O(n),n为单链表中数据结点的个数

    * 特点:头插法在进行创建单链表时,最后形成的链表的数据元素的顺序与最初的输入顺序完全相反

  * 2.尾插法建立单链表：
    
      * 首先确定要创建的单链表元素个数,进行循环输入结点数值
      
      * 每输入一个元素值都要创建一个单链表结点,将链表结点的数据域赋值为输入的值
      
      * 将每一次创建的单链表结点s,利用尾插法插入到链表尾部
      
      * 图示![image-20230615193326887](.\imgs\image-20230615193326887.png)
      
        
      
      * 代码
      
        <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾插法创建单链表</span></span><br><span class="line">singleLink* <span class="title function_">createSingleLink</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n, data;</span><br><span class="line">    SingleLink*r;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入创建链表的节点个数：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	SingleLink* L = (SingleLink*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SingleLink));</span><br><span class="line">	L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    r=L;<span class="comment">//r始终指向末尾元素</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		SingleLink* s = (SingleLink*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SingleLink));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入第%d个节点的值(int)：&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">		s-&gt;data = data;</span><br><span class="line">		s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next = s;</span><br><span class="line">        r = s;<span class="comment">//r始终指向末尾元素</span></span><br><span class="line">	&#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;<span class="comment">//将末尾元素的next指针域置位空</span></span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
        本算法的时间复杂度为O(n),n为单链表中数据结点的个数
      
      * 特点:尾插法在进行创建单链表时,最后形成的链表的数据元素的顺序与最初的输入顺序完全相同
</code></pre>
</li>
<li><p>3.创建一个空链表</p>
<ul>
<li><p>创建一个空链表很简单,只需要分配空间并肩将指针域初始化即可,就只有一个头结点</p>
</li>
<li><p>代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个空链表</span></span><br><span class="line">SingleLink* <span class="title function_">createSingleLink</span><span class="params">()</span> &#123;</span><br><span class="line">	SingleLink* head = (SingleLink*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SingleLink));</span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>4.输出单链表</p>
<ul>
<li><p>从第一个结点开始以此进行输出即可,注意循环结束条件</p>
</li>
<li><p>代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">outPut</span><span class="params">(SingleLink *head)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;打印链表：&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, head-&gt;next-&gt;data);</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>5．输出单链表的长度</p>
<ul>
<li><p>要想输出单链表的长度,则需要进行统计,我们只能从第一个元素开始进行遍历,利用一个变量用来记录经过了多少个结点,直至遍历到最后一个结点</p>
</li>
<li><p>代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getLength</span><span class="params">(SingleLink* head)</span> &#123;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">		len++;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>6．判断单链表是否为空</p>
<ul>
<li>判断单链表是否为空很简单,只需要判断头结点的指针域是否为NULL</li>
<li>代码<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断单链表h是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(SingleLink *h)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> h-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>输出单链表第k个元素</p>
<ul>
<li><p>大家在面对任何一个题目的时候,都要尽量的考虑周全.这里并没有告诉我们第k个元素一定存在,所以你一定要分情况处理.那就有两种情况:k&lt;1或k&gt;链表长度,这些都需要在代码里面进行体现</p>
</li>
<li><p>代码</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">outPutKth</span><span class="params">(SingleLink *h,<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;<span class="number">1</span>)<span class="keyword">return</span> ;<span class="comment">//如果k为小于1的数,肯定也是输入有误,直接结束程序</span></span><br><span class="line">	SingleLink* p = h-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (k--&amp;&amp;p) &#123;<span class="comment">//让k的值跟随p一起变化</span></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (k) &#123;<span class="comment">//如果k此时还不为0,说明我的链表都已经遍历完了,后续已经没有了,也就不存在第k个元素了</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;该链表不存在第%d个元素&quot;</span>,k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>输出指定元素的位置</p>
<ul>
<li><p>这是已知元素的值要我们在链表中找到它的位置,也就是单链表中的第几个元素.对于这类题,我们只能依次遍历该链表,并用一个变量来记录当前位置,该变量随着结点的遍历而自增.</p>
</li>
<li><p>代码</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">outPutPoint</span><span class="params">(SingleLink* h,<span class="type">int</span> p)</span> &#123;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (h-&gt;next) &#123;</span><br><span class="line">		k++;</span><br><span class="line">		<span class="keyword">if</span> (h-&gt;next-&gt;data == p) <span class="keyword">break</span>;</span><br><span class="line">		h = h-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在第k个元素位置上插入f元素</p>
<ul>
<li><p>同样我们需要首先找到第k-1个结点,然后将f插入到其之后</p>
</li>
<li><p>代码</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(SingleLink *h,<span class="type">int</span> k,<span class="type">char</span> f)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">	SingleLink* p = h;</span><br><span class="line">	<span class="keyword">while</span> (--k) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	SingleLink* newP = (SingleLink*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SingleLink));</span><br><span class="line">	newP-&gt;data = f;</span><br><span class="line"></span><br><span class="line">	newP-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = newP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>删除单链表的第k个元素</p>
<ul>
<li><p>同样我们需要找到第k-1个结点,并将该结点的指针域指向它的下下个结点</p>
</li>
<li><p>代码</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delKth</span><span class="params">(SingleLink *h,<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">	SingleLink* p = h-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (--k&amp;&amp;p) &#123;<span class="comment">//一定要搞清楚先减减和后减减的区别,什么时候用先减减,什么时候用后减减</span></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (k) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;该链表不存在第%d个元素&quot;</span>,k);</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><ul>
<li><p>双链表的结构</p>
<ul>
<li><p><img src="/.%5Cimgs%5Cimage-20230615203842886.png" alt="image-20230615203842886"></p>
</li>
<li><p>单链表只有指向后续结点的指针,在某一些应用场合可能并不是那么方便,于是便有了双链表,每一个结点都有两个指针域,分别指向前驱和后继.</p>
</li>
<li><p>双链表结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLink</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	DLink* next;</span><br><span class="line">	DLink* pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>1.创建双链表</p>
<ul>
<li><p>同单链表一样,分为头插法与尾插法,只是在设个过程当中,我们要注意处理每个结点的两个指针域的链接</p>
</li>
<li><p>头插法<img src="/.%5Cimgs%5Cimage-20230615210852918.png" alt="image-20230615210852918"></p>
</li>
<li><p>代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DLink* <span class="title function_">createDouLink</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n, data;</span><br><span class="line">	DLink* head = (DLink*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLink));</span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	head-&gt;pre = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入节点个数：n=&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入第%d个节点值:&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">		DLink* s = (DLink*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLink));</span><br><span class="line">		s-&gt;data = data;</span><br><span class="line">		<span class="comment">//头插法进行插入</span></span><br><span class="line">		s-&gt;next=head-&gt;next;</span><br><span class="line">		<span class="keyword">if</span>(head-&gt;next) head-&gt;next-&gt;pre=s;</span><br><span class="line">		s-&gt;pre=head;</span><br><span class="line">		head-&gt;next=s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尾插法<img src="/.%5Cimgs%5Cimage-20230615212106704.png" alt="image-20230615212106704"></p>
</li>
<li><p>代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DLink* <span class="title function_">createDouLink</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n, data;</span><br><span class="line">	DLink* head = (DLink*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLink));</span><br><span class="line">    DLink* r = head;</span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	head-&gt;pre = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入节点个数：n=&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入第%d个节点值:&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">		DLink* s = (DLink*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLink));</span><br><span class="line">		s-&gt;data = data;</span><br><span class="line">		<span class="comment">//尾插法进行插入</span></span><br><span class="line">		r-&gt;next = s;</span><br><span class="line">        s-&gt;pre = r;</span><br><span class="line">        r=s;</span><br><span class="line">	&#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;<span class="comment">//尾结点的指针域置为NULL</span></span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>2.双链表的插入操作：</p>
<ul>
<li><p>在双链表中进行插入,因其涉及的指针较多,所以需要一步一步捋清楚,谁先谁后.下面演示在p结点之后插入结点s的详细步骤<img src="/.%5Cimgs%5Cimage-20230615213706848.png" alt="image-20230615213706848"></p>
</li>
<li><p>代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;pre = s;</span><br><span class="line">s-&gt;pre = p;</span><br><span class="line">p-&gt;next = s;</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要注意的是,上面的语句不是唯一的,但是也不能任意调换顺序,第一步和第二步必须在第四步之前,否则在我们还没有操作p结点的后继结点就已经找不到了.</p>
</li>
</ul>
</li>
<li><p>双链表的删除操作</p>
<ul>
<li>在双链表中删除一个结点同样要考虑到指针的链接问题,下面演示删除q结点的详细步骤<img src="/.%5Cimgs%5Cimage-20230615214601654.png" alt="image-20230615214601654"></li>
<li>需要注意的是,这里我们仅仅给出了要删除的结点q,如果我们给出的是要删除结点的前驱结点或是后继结点,我们又能否成功地进行删除,留给同学们自行思考.</li>
</ul>
</li>
</ul>
<h3 id="循环链表-静态链表"><a href="#循环链表-静态链表" class="headerlink" title="循环链表&amp;&amp;静态链表"></a>循环链表&amp;&amp;静态链表</h3><ul>
<li><p>循环链表是另一种形式的链式存储结构.循环链表又循环单链表和循环双链表两种类型,循环单链表的结点类型和非循环单链表的结点类型相同,循环双链表与非循环双链表的结点类型相同</p>
</li>
<li><p>循环单链表：循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环</p>
</li>
<li><p>循环双链表：类比循环单链表，循环双链表链表区别于双链表就是首尾结点构成环</p>
<ul>
<li>当循环双链表为空表时，其头结点的prior域和next域都等于Head。<img src="/.%5Cimgs%5Cimage-20230616091703881.png" alt="image-20230616091703881"></li>
<li></li>
</ul>
</li>
<li><p>静态链表：静态链表是用数组来描述线性表的链式存储结构,结点也有数据域data和指针域next,与前面所讲的链表中的指针不同,这里的指针式结点的相对地址(数组下标),又称游标.静态链表和顺序表一样,也要预先分配一块连续的内存空间.</p>
<ul>
<li>数组第一个元素不存储数据，它的指针域存储第一个元素所在的数组下标。链表最后一个元素的指针域值为-1。</li>
<li>示例图<img src="/.%5Cimgs%5Cimage-20230616093854186.png" alt="image-20230616093854186"></li>
</ul>
</li>
</ul>
<h3 id="顺序表与链表对比"><a href="#顺序表与链表对比" class="headerlink" title="顺序表与链表对比"></a>顺序表与链表对比</h3><table>
<thead>
<tr>
<th align="center">存储方式&#x2F;特性对比</th>
<th>存取方式</th>
<th>结构</th>
<th>基本操作(增删查)</th>
<th>空间分配</th>
</tr>
</thead>
<tbody><tr>
<td align="center">顺序表</td>
<td>可顺序存储,可随机存取</td>
<td>逻辑上相邻,物理上也相邻</td>
<td>顺序表无序:若按值查找,时间复杂度O(n);若按序查找,随机特性,时间复杂度O(1);<br /> 顺序表有序:可采用折半查找,时间复杂度O(lgn)<br />顺序表的删除,插入平均需要移动半个表长的元素</td>
<td>静态分配,预先分配过小,容易溢出;预先分配过大,内存浪费</td>
</tr>
<tr>
<td align="center">链表</td>
<td>只能从表头顺序存取元素</td>
<td>逻辑上相邻,物理上不一定相邻</td>
<td>链表无论其有序还是无序都只能从表头元素依次查找,时间复杂度O(n),而插入.删除则只需要修改对应结点的指针域即可,时间复杂度O(1)</td>
<td>需要时分配,只要有空间就可以分配,操作灵活&#x2F;高效</td>
</tr>
</tbody></table>
<h2 id="第三章：栈和队列"><a href="#第三章：栈和队列" class="headerlink" title="第三章：栈和队列"></a>第三章：栈和队列</h2><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>从组成元素的逻辑关系来看,栈和队列都属于线性结构.栈和队列与线性表的不同之处在于它们的相关运算具有一些特殊性.更准确地说,一般线性表上的插入&#x2F;删除运算不受限制,而栈和队列上的插入 删除运算均会受到某种特殊限制,因此栈和队列也称为操作受限的线性表.</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li><p>栈（Stack）定义：只允许在一端进行插入或删除操作的线性表。</p>
</li>
<li><p>示意图<img src="/.%5Cimgs%5Cimage-20230616105754903.png" alt="image-20230616105754903"></p>
</li>
<li><p>相关术语:</p>
<ul>
<li>栈顶（Top）：线性表允许进行插入和删除的那一端。</li>
<li>栈底（Bottom）：固定的，不允许进行插入和删除的另一端</li>
</ul>
</li>
<li><p>基础操作:</p>
<ul>
<li>入栈:push</li>
<li>出栈:pop</li>
<li>判断栈满:isFull</li>
<li>判断栈空:isEmpty</li>
<li>查看栈顶元素:top</li>
<li>销毁栈:destory</li>
</ul>
</li>
<li><p>特点：<br>1.栈是受限的线性表，所以自然具有线性关系。<br>2.栈中元素后进去的必然先出来，即后进先出</p>
</li>
<li><p>实现方式:</p>
<ul>
<li><p>顺序栈</p>
<ul>
<li><p>栈是线性表的特例，那栈的顺序存储也是线性表顺序存储的简化。栈的顺序存储结构也叫作顺序栈。</p>
</li>
<li><p>顺序栈结构体</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">	<span class="type">int</span>* arr;	<span class="comment">//内存首地址</span></span><br><span class="line">	<span class="type">int</span>  len;	<span class="comment">//栈的容量</span></span><br><span class="line">	<span class="type">int</span> top; 	<span class="comment">//栈的下标</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>顺序栈的存放过程<img src="/.%5Cimgs%5Cimage-20230616144110206.png" alt="image-20230616144110206"></p>
</li>
<li><p>顺序栈的操作</p>
<ul>
<li><p>1.初始化栈:用户指定栈的大小,top指针初始化为-1,代表栈空</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个栈</span></span><br><span class="line">Stack *<span class="title function_">createStack_S</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">	Stack *<span class="built_in">stack</span> = (Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));<span class="comment">//给栈分配空间</span></span><br><span class="line">	<span class="built_in">stack</span>-&gt;arr = (NODETYPE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODETYPE)*size);<span class="comment">//给内存首地址分配空间，大小用户指定</span></span><br><span class="line">	<span class="built_in">stack</span>-&gt;len = size;<span class="comment">//栈容量</span></span><br><span class="line">	<span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;<span class="comment">//栈顶下标，当前无元素，故为-1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>2.判满：如果top指针和数组长度-1相等则栈满</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断栈满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">full</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top + <span class="number">1</span> &gt;= <span class="built_in">stack</span>-&gt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>3.判空：top指针等于-1代表当前栈为空</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>4.入栈:元素入栈首先要判断栈是否已满,未满才能放入数据,且要先将top指针+1,移向下一个位置,再将元素存入top下标所指位置</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>, NODETYPE p)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (full(<span class="built_in">stack</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	*(<span class="built_in">stack</span>-&gt;arr + ++<span class="built_in">stack</span>-&gt;top) = p;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>5.出栈：出栈的前提条件是栈中有元素,而后直接top指针减一</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (empty(<span class="built_in">stack</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">stack</span>-&gt;top--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>6.读取栈顶元素：读取栈顶元素的前提是栈不空,而后直接返回top指针下标的元素,与出栈不同的是,不再对top指针进行减一操作.</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看栈顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">top</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (empty(<span class="built_in">stack</span>)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> *(<span class="built_in">stack</span>-&gt;arr + <span class="built_in">stack</span>-&gt;top);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>7.销毁栈:先释放掉栈中的数组,再将栈空间释放</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destory</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">stack</span>-&gt;arr);</span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>共享栈</p>
<ul>
<li><p>顺序栈的存储空间大小需要事先开辟好，很多时候对每个栈各自单独开辟存储空间的利用率不如将各个栈的存储空间共享</p>
</li>
<li><p>示意图<img src="/.%5Cimgs%5Cimage-20230616151617261.png" alt="image-20230616151617261"></p>
</li>
<li><p>共享栈的结构:我们用一个大小为2的数组来分别表示0号栈和1号栈</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	TYPE* arr;	<span class="comment">//内存首地址</span></span><br><span class="line">	<span class="type">int</span> top[<span class="number">2</span>]; 	<span class="comment">//栈的下标</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
<li><p>共享栈的操作：</p>
<ul>
<li><p>1.初始化栈:用户指定栈的大小,两个栈的栈顶指针都指向栈顶元素,top0&#x3D;-1时0号栈为空,top1&#x3D;MaxSize时1号栈为空</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个栈</span></span><br><span class="line">Stack *<span class="title function_">createStack_S</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">	Stack *<span class="built_in">stack</span> = (Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));<span class="comment">//给栈分配空间</span></span><br><span class="line">	<span class="built_in">stack</span>-&gt;arr = (TYPE *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TYPE)*size);<span class="comment">//给内存首地址分配空间，大小用户指定</span></span><br><span class="line">	<span class="built_in">stack</span>-&gt;top[<span class="number">0</span>] = <span class="number">-1</span>;<span class="comment">//栈顶下标，当前无元素，故为-1</span></span><br><span class="line">	<span class="built_in">stack</span>-&gt;top[<span class="number">1</span>] = size;<span class="comment">//栈顶下标，当前无元素，故为size</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>2.判满：画画图很容易发现当top1-top0&#x3D;1时栈满</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断栈满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">full</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top[<span class="number">1</span>]-<span class="built_in">stack</span>-&gt;top[<span class="number">0</span>] == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>3.判空：top0指针等于-1代表0号栈为空;top1指针等于MaxSize时代表1号栈为空</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(<span class="type">int</span> i,Stack *<span class="built_in">stack</span>,<span class="type">int</span> size)</span> &#123;<span class="comment">//i为栈号</span></span><br><span class="line">	<span class="keyword">switch</span> (i) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top[<span class="number">0</span>] == <span class="number">-1</span>; </span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top[<span class="number">1</span>] == size;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.入栈:元素入栈首先要判断栈是否已满,未满才能放入数据,然后判断要入的栈,且要先将top指针+1,移向下一个位置,再将元素存入top下标所指位置</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>, TYPE data,<span class="type">int</span> i)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (full(<span class="built_in">stack</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">switch</span> (i) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		*(<span class="built_in">stack</span>-&gt;arr + ++<span class="built_in">stack</span>-&gt;top[i]) = data;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		*(<span class="built_in">stack</span>-&gt;arr + --<span class="built_in">stack</span>-&gt;top[i]) = data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>5.出栈：出栈的前提条件是栈中有元素,而后判断哪个栈要出栈,直接top指针减一</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop</span><span class="params">(<span class="type">int</span> i,Stack *<span class="built_in">stack</span>,<span class="type">int</span> size)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (empty(i,<span class="built_in">stack</span>,size)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">switch</span> (i) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="built_in">stack</span>-&gt;top[i]--;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="built_in">stack</span>-&gt;top[i]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>链式栈</p>
<ul>
<li><p>栈是线性表的特例，线性表的存储结构还有链式存储结构，所以也可以用链表的方式来实现栈。栈的链式存储结构也叫作链栈。</p>
</li>
<li><p>示意图:<img src="/.%5Cimgs%5Cimage-20230616153903228.png" alt="image-20230616153903228"></p>
</li>
<li><p>链栈的结构体:所谓链栈,就是利用链表来模拟栈,所以我们这里的top指针为链表结点,它作为头指针指向头结点,从而栈顶元素为top-&gt;next.当然你也可以将top指向栈顶元素,因人而异,没有对错,重在理解.</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">singleLink</span> &#123;</span></span><br><span class="line">	NODETYPE data;</span><br><span class="line">	singleLink* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//链栈</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span> &#123;</span></span><br><span class="line">	<span class="comment">//int data;</span></span><br><span class="line">	singleLink* top;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链栈的各类操作</p>
<ol>
<li><p>初始化链栈:如下所示,我们需要初始化一个链表,然后将top指针赋值为头指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建链栈</span></span><br><span class="line">LinkStack* <span class="title function_">createStack_L</span><span class="params">()</span> &#123;</span><br><span class="line">	singleLink* h;</span><br><span class="line">	LinkStack* ls = (LinkStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">	singleLink* <span class="title function_">createSingleLink</span><span class="params">()</span>;</span><br><span class="line">	h = createSingleLink();</span><br><span class="line">	ls-&gt;top = h;</span><br><span class="line">	<span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>入栈:其实就是利用头插法,将新节点插入链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">push</span><span class="params">(LinkStack* ls, NODETYPE data)</span> &#123;<span class="comment">//栈顶插入</span></span><br><span class="line">	singleLink* newd = (singleLink*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(singleLink));</span><br><span class="line">	newd-&gt;data = data;</span><br><span class="line"></span><br><span class="line">	newd-&gt;next = ls-&gt;top-&gt;next;</span><br><span class="line">	ls-&gt;top-&gt;next = newd;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>出栈:将栈顶元素摘出来,注意防止断链</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop</span><span class="params">(LinkStack* ls)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (!ls-&gt;top-&gt;next)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	singleLink* p = ls-&gt;top-&gt;next;</span><br><span class="line">	ls-&gt;top-&gt;next = ls-&gt;top-&gt;next-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>查看栈顶元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看栈顶元素</span></span><br><span class="line">NODETYPE <span class="title function_">top</span><span class="params">(LinkStack* ls)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (!ls-&gt;top-&gt;next) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> ls-&gt;top-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>特点<br>1.链栈一般不存在栈满的情况。<br>2.空栈的判定条件通常定为top-&gt;next&#x3D;&#x3D;NULL；当然也具体看你如何定义栈顶</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li><p>队列(Queue)定义:队列是只允许在一端进行插入，而在另一端进行删除的线性表</p>
</li>
<li><p>示意图:<img src="/.%5Cimgs%5Cimage-20230616155924467.png" alt="image-20230616155924467"></p>
</li>
<li><p>相关术语:</p>
<ul>
<li>队头（Front）：允许删除的一端，又称为队首。</li>
<li>队尾（Rear）： 允许插入的一端。</li>
</ul>
</li>
<li><p>基础操作:</p>
<ul>
<li>判断队空</li>
<li>判断队满</li>
<li>入队</li>
<li>出队</li>
</ul>
</li>
<li><p>特点:</p>
<ul>
<li>队列同样是受限的线性表,具有线性关系</li>
<li>先进入队列的元素必然先出来,即先进先出</li>
</ul>
</li>
<li><p>实现方式:</p>
<ul>
<li><p>顺序队列:队列是线性表的特例，那队列的顺序存储也是线性表顺序存储的简化。队列的顺序存储结构也叫作顺序队列 。 (为使空间合理利用,我们默认采用循环队列)</p>
</li>
<li><p>顺序队列结构体:</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Squeue</span> &#123;</span></span><br><span class="line">	NODETYPE* arr;</span><br><span class="line">	<span class="type">int</span> front, rear;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>顺序队列的存放过程:<img src="/.%5Cimgs%5Cimage-20230616165201566.png" alt="image-20230616165201566"></p>
</li>
</ul>
</li>
<li><p>循环队列</p>
<ul>
<li><p>循环队列的基本操作:</p>
<ol>
<li><p>初始化队列:利用数组,且进行循环利用空间,初始化时将front与rear均设为0,代表队列空,与之对应的就是我们牺牲一个存储单元来判断队满,后续介绍</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建队列</span></span><br><span class="line">Squeue *<span class="title function_">createQueue</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	Squeue *sq = ( Squeue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>( Squeue));</span><br><span class="line">	sq-&gt;arr = (NODETYPE *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODETYPE)*n);<span class="comment">//数组大小</span></span><br><span class="line">	sq-&gt;front = <span class="number">0</span>;</span><br><span class="line">	sq-&gt;rear = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> sq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判满:判断队满(这里采用牺牲一个存储单元来实现,约定队头指针在队尾指针的下一个位置作为队满的标志)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Squeue *sq, <span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (sq-&gt;rear + <span class="number">1</span>) % maxSize == sq-&gt;front;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判空:当队头指针与队尾指针重合时队列空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断队空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Squeue *sq)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> sq-&gt;front == sq-&gt;rear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计队列中的元素个数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	情况一:  当rear大于front时，循环队列的长度：rear-front</span></span><br><span class="line"><span class="comment">    情况二:  当rear小于front时，循环队列的长度:分为两部分计算 0+rear   和   Quesize-front  ,  将两部分的长度合并到一起即为: rear-front+Quesize</span></span><br><span class="line"><span class="comment">    所以将两种情况合为一种，即为:  总长度是(rear-front+Quesize)%Quesize</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(Squeue *sq, <span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (sq-&gt;rear - sq-&gt;front + maxSize) % maxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>入队:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">enQueue</span><span class="params">(Squeue *sq, NODETYPE data, <span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (isFull(sq, maxSize)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	sq-&gt;arr[sq-&gt;rear] = data;</span><br><span class="line">	sq-&gt;rear = (sq-&gt;rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>出队</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">deQueue</span><span class="params">(Squeue *sq, NODETYPE*data,<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (isEmpty(sq)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	*data = sq-&gt;arr[sq-&gt;front];</span><br><span class="line">	sq-&gt;front = (sq-&gt;front + <span class="number">1</span>) % maxSize;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>循环队列判空判满的三种方式:</p>
<ul>
<li>代码中采用的方式,牺牲一个存储单元.front&#x3D;&#x3D;rear为空,(rear-front+maxsize)%maxsize</li>
<li>在队列结构体中新增表示元素个数的数据成员.这样的话,队空的条件就为size&#x3D;&#x3D;0,队满的条件就为size&#x3D;&#x3D;maxsize</li>
<li>在队列结构体中新增tag数据成员,用以区分队满还是队空.tag等于0时,同判断front&#x3D;&#x3D;rear和tag的值</li>
</ul>
</li>
</ul>
</li>
<li><p>链式队列</p>
<ul>
<li><p>队列的链式存储结构，其实就是线性表的单链表，只不过需要加点限制，只能表尾插入元素，表头删除元素。为了方便操作，我们分别设置队头指针和队尾指针，队头指针指向头结点，队尾指针指向尾结点。</p>
</li>
<li><p>链式队列示意图<img src="/.%5Cimgs%5Cimage-20230616185423493.png" alt="image-20230616185423493"></p>
<ul>
<li>不带头结点的链式队列,出队时,首先判断队是否为空,若不空,则取出对头元素,将其从链表中摘除,并让front指向下一个结点(若该结点为最后一个结点,则置front和rear都为null).入队时,建立一个新结点,将新结点插入到链表的尾部,并让rear指向这个新插入的结点(若原队列为空队,则令front也指向该结点).<br>  我们可以发现,不带头结点的链式队列在操作上往往十分麻烦,因此我们通常将链式队列设计成一个带头结点的单链表,这样插入与删除操作就统一了.</li>
</ul>
</li>
<li><p>链式队列的结构体</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">singleLink</span> &#123;</span></span><br><span class="line">	NODETYPE data;</span><br><span class="line">	singleLink* next;</span><br><span class="line">&#125;; </span><br><span class="line">`````````````````````````````````````````````````````````````````<span class="comment">//链队</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkQueue</span> &#123;</span></span><br><span class="line">	singleLink* front, * rear;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
<li><p>链式队列的基本操作</p>
<ul>
<li><p>初始化链式队列:</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建链队</span></span><br><span class="line">LinkQueue* <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">	singleLink* h;</span><br><span class="line">	LinkQueue* lq = (LinkQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkQueue));</span><br><span class="line">	singleLink* <span class="title function_">createSingleLink</span><span class="params">()</span>;</span><br><span class="line">	h = createSingleLink();</span><br><span class="line">	lq-&gt;front = lq-&gt;rear = h;</span><br><span class="line">	<span class="keyword">return</span> lq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判空:</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(LinkQueue* lq)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> lq-&gt;front == lq-&gt;rear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>1.入队：我们知道队列只能从队尾插入元素，队头删除元素。于是入队就是在队尾指针进行插入结点操作。链队的插入操作和单链表的尾插入操作是一致的。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">enQueue</span><span class="params">(LinkQueue* lq, NODETYPE data)</span> &#123;<span class="comment">//队尾插入</span></span><br><span class="line">	singleLink* newd = (singleLink*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(singleLink));</span><br><span class="line">	newd-&gt;data = data;</span><br><span class="line"></span><br><span class="line">	lq-&gt;rear-&gt;next = newd;</span><br><span class="line">	lq-&gt;rear = newd;</span><br><span class="line">	lq-&gt;rear-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>2.出队：出队就是头结点的后继结点出队，然后将头结点的后继改为它后面的结点。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">deQueue</span><span class="params">(LinkQueue* lq, NODETYPE* data)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (isEmpty(lq))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	singleLink* p = lq-&gt;front-&gt;next;<span class="comment">//保存下一个节点</span></span><br><span class="line">	*data = lq-&gt;front-&gt;next-&gt;data;<span class="comment">//取出队首节点值</span></span><br><span class="line">	lq-&gt;front-&gt;next = p-&gt;next;<span class="comment">//删除队首节点</span></span><br><span class="line">	<span class="keyword">if</span> (lq-&gt;rear == p) &#123;</span><br><span class="line">		lq-&gt;rear = lq-&gt;front;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>双端队列</p>
<ul>
<li>双端队列是指允许两端都可以进行入队和出队操作的队列</li>
</ul>
</li>
</ul>
<h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><ul>
<li>1、括号匹配：假设有两种括号，一种圆的()，一种方的[]，嵌套的顺序是任意的。<ul>
<li><p>算法思想：若是左括号，入栈；若是右括号，出栈一个左括号判断是否与之匹配；检验到字符串尾，还要检查栈是否为空。只有栈空，整个字符串才是括号匹配的。</p>
</li>
<li><p>代码</p>
</li>
</ul>
</li>
<li>2、表达式求值：<ul>
<li></li>
<li>规则：从左到右扫描表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈然后跟这个符号进行运算，最后将运算结果进栈，直到最终获得结果。</li>
</ul>
</li>
<li>3、递归：<ul>
<li>要理解递归，你要先理解递归，直到你能理解递归。<br>  如果在一个函数、过程或数据结构的定义中又应用了它自身，那么这个函数、过程或数据结构称为是递归定义的，简称递归。递归最重要的是递归式和递归边界。</li>
<li>1.阶乘<ul>
<li>时间复杂度：O(NlogN)</li>
</ul>
</li>
<li>2.斐波那契数列<ul>
<li>时间复杂度   O(2^n)</li>
</ul>
</li>
</ul>
</li>
<li>概要: 如何将中缀表达式转换成后缀表达式？<ul>
<li>1.按运算符优先级对所有运算符和它的运算数加括号。(原本的括号不用加)</li>
<li>2.把运算符移到对应的括号后。</li>
<li>3.去掉括号。</li>
<li>例子</li>
</ul>
</li>
</ul>
<h2 id="第四章：树"><a href="#第四章：树" class="headerlink" title="第四章：树"></a>第四章：树</h2><h3 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h3><ul>
<li>树的定义<ul>
<li>树是由n个(n≥0)个结点(或元素)组成的有限集合</li>
<li>当n&#x3D;0时,称作空树</li>
<li>若n&gt;0,在这n个结点中有且仅有一个结点作为树的根结点,简称为根</li>
<li>若n&gt;1,除根结点以外的其他结点克分为m(m≥0)个互不相交的有限集T1,T2,…,Tm,其中每个子集本身又是一颗符合本定义的树,称为根结点的子树.</li>
<li>显然,树的定义是递归的,因为在树的定义中又用到了树的定义.树既是一种逻辑结构,它同时又是一种分层结构</li>
</ul>
</li>
<li>基本术语<img src="/.%5Cimgs%5Cimage-20230616203216532.png" alt="image-20230616203216532"><ul>
<li>结点的度与树的度:树中的某个结点的子树个数称为该结点的度;树中所有结点的度中的最大值称为树的度,通常将度为m的树称为m次树,如上图是一棵3次树.</li>
<li>分支结点与叶子结点:树中度不为0的结点称为非终端结点,也称为分支结点.度为0的结点称为叶子结点.在分支节点中,每个结点的分支数就是该结点的度.如对于度为1的结点,其分支数为1,被称为单分支结点;对于度为2的结点,称为双分支结点,以此类推.如上图所示:A B C D G 是分支结点，其余结点是叶子结点</li>
<li>路径与路径长度：树中的两个结点的路径就是这两个结点之间所经过的结点序列所构成。而路径长度则是路径上所经过的边的个数</li>
<li>孩子结点、双亲结点、兄弟结点：在一棵树中，每个结点的后继结点被称为该结点的孩子结点。如C是A的孩子结点。相应的，该结点称为孩子结点的双亲结点。具有同一双亲结点的孩子结点互为兄弟结点。</li>
<li>结点层次和树的高度：结点的层次是从树根开始定义，根结点为第一层，其孩子结点为第二层，以此类推。双亲在同一层次的结点互为堂兄弟。树的深度（高度）是树中结点的最大层数，上图中树的高度为4.</li>
<li>有序树和无序树：若树中各结点的子树是按照一定的次序从左向右安排的，且相对次序是不能随意变换的，则称为有序树，否则称为无序树。默认有序树。</li>
<li>森林:n(n≥0)个互不相交的树的集合称为森林。森林和树要结合起来理解，把树的根去掉，其余子树就变成了森林，反之，把m(m&gt;1)棵独立的树上加上一个根结点，并把这m棵树作为该结点的子树，则森林就变成了一棵树。</li>
</ul>
</li>
<li>树的性质<ul>
<li>1.树中的结点数等于所有结点的度数加1。<ul>
<li>证明：不难想象，除根结点以外，每个结点有且仅有一个指向它的前驱结点。也就是说每个结点和指向它的分支一一对应。<br>  假设树中一共有b个分支，那么除了根结点，整个树就包含有b个结点，所以整个树的结点数就是这b个结点加上根结点，设为n，则n&#x3D;b+1。而分支数b也就是所有结点的度数，证毕。</li>
</ul>
</li>
<li>2.度为m的树中第i层上至多有m^(i−1)个结点（i≥1）。<ul>
<li>证明：（数学归纳法）<br>  首先考虑i&#x3D;1的情况：第一层只有根结点，即一个结点，i&#x3D;1带入式子满足。<br>  假设第i-1层满足这个性质，第i-1层最多有m i-2个结点。<br>  ……… ……….<br>  i-1层<br>  ………<br>  又因为树的度为m,所以对于第i-1层的每个结点，最多<br>  有m个孩子结点。所以第i层的结点数最多是i-1层的m<br>  倍，所以第i层上最多有m ^(i-1)个结点。</li>
</ul>
</li>
<li>3.高度为h的m叉树至多有(m^h-1)&#x2F;(m-1)个结点</li>
<li>4.具有n个结点的m叉树的最小高度为logm(n(m-1)+1)</li>
</ul>
</li>
</ul>
<h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><ul>
<li>顺序存储结构<ul>
<li>双亲表示法：用一组连续的存储空间存储树的结点，同时在每个结点中，用一个变量存储该结点的双亲结点在数组中的位置。</li>
</ul>
</li>
<li>链式存储结构<ul>
<li><p>孩子表示法：把每个结点的孩子结点排列起来存储成一个单链表。所以n个结点就有n个链表；<br>  如果是叶子结点，那这个结点的孩子单链表就是空的；<br>  然后n个单链表的的头指针又存储在一个顺序表（数组）中。</p>
</li>
<li><p>孩子兄弟表示法：顾名思义就是要存储孩子和孩子结点的兄弟，具体来说，就是设置两个指针，分别指向该结<br>  点的第一个孩子结点和这个孩子结点的右兄弟结点。</p>
</li>
</ul>
</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul>
<li><p>定义</p>
<ul>
<li>二叉树是n（n≥0）个结点的有限集合：<br>① 空二叉树，即n&#x3D;0。<br>② 由一个根结点和两个互不相交的被称为根的左子树<br>和右子树组成。左子树和右子树又分别是一棵二叉树。 <ul>
<li>1.每个结点最多有两棵子树。</li>
<li>2.左右子树有顺序</li>
</ul>
</li>
<li>两个易混概念：二叉树和度为2(2次树)的树<ul>
<li>度为2的树中至少有一个结点的度为2，而二叉树没有这个要求</li>
<li>度为2的树不区分左右子树，而二叉树是严格区分左右子树的</li>
</ul>
</li>
</ul>
</li>
<li><p>二叉树的五种基本形态：</p>
<ul>
<li><p>1.空树<img src="/.%5Cimgs%5Cimage-20230617095250374.png" alt="image-20230617095250374"></p>
</li>
<li><p>2.只有一个根结点<img src="/.%5Cimgs%5Cimage-20230617095311945.png" alt="image-20230617095311945"></p>
</li>
<li><p>3.根结点只有左子树<img src="/.%5Cimgs%5Cimage-20230617095326501.png" alt="image-20230617095326501"></p>
</li>
<li><p>4.根结点只有右子树<img src="/.%5Cimgs%5Cimage-20230617095341367.png" alt="image-20230617095341367"></p>
</li>
<li><p>5.根结点既有左子树又有右子树<img src="/.%5Cimgs%5Cimage-20230617095353612.png" alt="image-20230617095353612"></p>
</li>
</ul>
</li>
<li><p>特殊二叉树</p>
<ul>
<li><p>1.满二叉树:在一颗二叉树中，如果所有分支结点都有左孩子结点和右孩子结点，并且叶子结点都集中在二叉树的最下一层，这样的二叉树称作满二叉树。非空满二叉树的特点：</p>
<ul>
<li><p>叶子结点都在最下一层</p>
</li>
<li><p>只有度为0和度为2的结点</p>
</li>
<li><p>常对满二叉树进行编号：约定编号从树根为1开始，按照层数从小到大、同一层次从左到右的次序进行，这样，对于编号为i的结点，若有双亲，则双亲编号为<br>$$<br>\lfloor i&#x2F;2 \rfloor<br>$$<br>若有左孩子，则左孩子为2i；若有右孩子，则右孩子为2i+1。</p>
</li>
</ul>
</li>
<li><p><img src="/.%5Cimgs%5Cimage-20230617095552896.png" alt="image-20230617095552896"></p>
</li>
<li><p>2.完全二叉树：若二叉树中最多只有最下面两层的结点的度数可以小于2，并且最下面一层的叶子结点都依次排列在该层最左边的位置上，这样的二叉树称为完全二叉树。非空完全二叉树的特点：</p>
<ul>
<li>叶子结点只可能在最小面两层中出现；</li>
<li>对于最大层次的叶子结点，都依次排列在该层最左边的位置上；</li>
<li>如果有度为1的结点，只可能有一个，且该结点只有左孩子没有右孩子；</li>
<li>按层序编号时，一旦出现编号为i的结点是叶子结点或只有左孩子，则编号大于i的结点均为叶子结点；</li>
<li>当节点总数n为奇数时，n1&#x3D;0，当结点总数n为偶数时，n1&#x3D;1</li>
</ul>
<p><img src="/.%5Cimgs%5Cimage-20230617095921960.png" alt="image-20230617095921960"></p>
</li>
<li><p>3.二叉排序树：左子树上所有结点的关键字均小于根结点的关键字；右子树上的所有结点的关键字均大于根结点的关键字；左子树和右子树又各是一颗二叉排序树。</p>
</li>
<li><p>4.平衡二叉树：树上任意一个结点的左右子树的高度差不超过1。</p>
</li>
</ul>
</li>
<li><p>二叉树的性质</p>
<ul>
<li><p>1.非空二叉树上叶子结点数等于双分支结点数加1</p>
<p>证明:设二叉树上的叶子结点数为$n_0$,单分支结点数为$n_1$、双分支结点数为$n_2$,总结点数为$n$(如果没有特别指出,后面均采用这种设定),则总结点数$n&#x3D;n_0+n_1+n_2$。在一棵二叉树中,所有结点的分支数(即所有结点的度之和)应等于单分支结点数加上双分支结点数的两倍,即总的分支数&#x3D;$n_1+2n_2$。</p>
<p>由于二叉树中除了根结点以外,每个结点都有唯一的一个分支指向它,因此在二叉树中总的分支数&#x3D;$n-1$。</p>
<p>从而：<br>$$<br>\begin{cases}<br>n &#x3D; n_0+n_1+n_2\<br>n_{分支}&#x3D;n_1+2n_2\<br>n_{分支}&#x3D;n-1</p>
<p>\end{cases}<br>\Longrightarrow</p>
<p>n_1+2n_2&#x3D;n_0+n_1+n_2-1<br>\Longrightarrow<br>n_0&#x3D;n_2+1<br>$$<br>由上述3个等式可得$n_0&#x3D;n_2+1$。</p>
</li>
<li><p>2.非空二叉树上第K层上至多有$2^{k−1}$个结点（K≥1）</p>
</li>
<li><p>3.高度为H的二叉树至多有2^H-1个结点（H≥1）</p>
</li>
<li><p>4.具有N个（N&gt;0）结点的完全二叉树的高度为$ \lceil log_2(N+1)\rceil$或$\lfloor log2N\rfloor+1$。</p>
</li>
</ul>
</li>
</ul>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><ul>
<li><p>顺序存储</p>
<ul>
<li>二叉树的顺序存储结构就是用一组地址连续的存储单元来存放二叉树的数据元素,因此必须确定好树中各数据元素的存放次序,使得各数据元素在这个存放次序中的相互位置能反映出数据元素之间的逻辑关系。<br>对于完全二叉树和满二叉树,树中结点的层序编号可以唯一地反映出结点之间的逻辑关系,所以可以用一维数组按从上到下、从左到石的顺序存储树中的所有结点值,通过数组元素的下标关系反映完全二叉树或满二叉树中结点之间的逻辑关系。<br>例如,上图所示的完全二叉树对应的顺序存储结构如下图所示,编号为i的结点值存放在数组下标为i的元素中(‘#’表示空结点)。由于C&#x2F;C++语言中的数组下标从0开始,这里为了一致性而没有使用下标为0的数组元素。<img src="/.%5Cimgs%5Cimage-20230617144935518.png" alt="image-20230617144935518"></li>
<li>大家可以很容易发现对于满二叉树和完全二叉树而言，这样的做法是十分方便的，但是如果是一般的二叉树，我们若还想让下标满足完全二叉树的特性，就不得不增添许多的空结点，这就使得空间浪费严重。所以一般而言，对于一般二叉树采用下面介绍的链式存储方式。</li>
</ul>
</li>
<li><p>链式存储</p>
<ul>
<li><p>定义：二叉树的链式存储结构是指用一个链表来存储一颗二叉树，二叉树中的每一个结点用链表中的一个结点来存储。</p>
</li>
<li><p>结构：二叉树链式存储结构的标准存储结构如下<img src="/.%5Cimgs%5Cimage-20230617152049024.png" alt="image-20230617152049024"></p>
<p>其中data表示值域，存放着对应的数据元素，lchild和rchild分别表示左指针域和右指针域，分别用于存储左孩子结点和右孩子结点的地址</p>
</li>
<li><p>结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">biTree</span> &#123;</span></span><br><span class="line">	BNODETYPE data;</span><br><span class="line">	biTree* lchild;</span><br><span class="line">	biTree* rchild;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例图</p>
<p><img src="/.%5Cimgs%5Cimage-20230617152826646.png" alt="image-20230617152826646"></p>
</li>
<li><p>特性：在含有n个结点的二叉链表中，含有n+1个空链域</p>
<ul>
<li>证明：除根结点以外，其余结点都对应一条边，也就是会消耗掉一个指针域，总共消耗掉n-1个指针域，而每个结点有左右两个指针域，即共有2n个指针域，那么空链域即为2n-(n-1)&#x3D;n+1</li>
</ul>
</li>
<li><p>优点：节省存储空间，访问孩子结点方便</p>
</li>
<li><p>缺点：访问双亲结点不方便（可增加一个指向双亲的指针域，了解即可）</p>
</li>
</ul>
</li>
</ul>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul>
<li><p>概念：二叉树的遍历是指按照一定的次序访问二叉树中的所有结点，并且每个结点仅被访问一次。接下来以下图为例讲解相关遍历</p>
</li>
<li><p><img src="/.%5Cimgs%5Cimage-20230617154222212.png" alt="image-20230617154222212"></p>
</li>
<li><p>先序、中序、后序遍历递归算法</p>
<ul>
<li><p>先序遍历：ABEFCH<br>1）访问根结点；<br>2）先序遍历左子树；<br>3）先序遍历右子树。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序递归遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(biTree* T)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, T-&gt;data);</span><br><span class="line">		preOrder(T-&gt;lchild);</span><br><span class="line">		preOrder(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>中序遍历：EBFAHC<br>1）中序遍历左子树；<br>2）访问根结点；<br>3）中序遍历右子树。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序递归遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(biTree* T)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		inOrder(T-&gt;lchild);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, T-&gt;data);</span><br><span class="line">		inOrder(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>后序遍历：EFBHCA<br>1）后序遍历左子树；<br>2）后序遍历右子树；<br>3）访问根结点。		</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序递归遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">postOrder</span><span class="params">(biTree* T)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		postOrder(T-&gt;lchild);</span><br><span class="line">		postOrder(T-&gt;rchild);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, T-&gt;data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>上面的代码中对于访问根结点采取的是直接输出根结点值，在实际应用中我们可以对其进行各类操作，如结点计数、删除结点等。对于递归的理解，一定要结合画图进行。</p>
</li>
<li><p>先序、中序、后序非递归遍历算法：</p>
<blockquote>
<p>二叉树是一种递归数据结构，其先序、中序和后序遍历算法采用递归方式设计师理所应当的，但考试的时候也仍然有可能考到让你用非递归方式来进行解题的情况，所以我们同样需要去掌握这三种非递归遍历算法。</p>
</blockquote>
<ul>
<li><p>先序非递归遍历：由现先序遍历过程可知，先访问根结点，再遍历左子树，最后遍历右子树。所以先访问根结点及其所有左下结点，但是因为在二叉链表中并没有指向双亲结点的指针，所以我们需要将已访问过的结点存入栈中。此时栈顶结点要么没有左子树，要么左子树已遍历过，所以转向它的右子树，对右子树的处理与上述过程类似。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(biTree *T, Stack *s)</span> &#123;<span class="comment">//先序遍历</span></span><br><span class="line">	biTree *p = T;</span><br><span class="line">	<span class="type">bool</span> <span class="title function_">empty</span><span class="params">(Stack *)</span>;</span><br><span class="line">	<span class="type">bool</span> <span class="title function_">push</span><span class="params">(Stack *, biTree *)</span>;</span><br><span class="line">	biTree *<span class="title function_">top</span><span class="params">(Stack *)</span>;</span><br><span class="line">	<span class="type">bool</span> <span class="title function_">pop</span><span class="params">(Stack *)</span>;</span><br><span class="line">	<span class="keyword">while</span> (p || !empty(s)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p) &#123;<span class="comment">//一路向左</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, p-&gt;data);<span class="comment">//打印当前元素</span></span><br><span class="line">			push(s, p);</span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p = top(s);</span><br><span class="line">			pop(s);<span class="comment">//栈顶元素出栈</span></span><br><span class="line">			p = p-&gt;rchild;<span class="comment">//向右寻找</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<strong>注</strong>：外循环中的条件是指针p不为空或者栈不为空，这是因为，p是指向当前所要访问元素，只要它不为空我们就要就行访问和入栈，当p一路向左直至为空的时候，说明此时应该转头去访问双亲结点（如果有）的右子树了，也就是这里我们要去判断栈是否为空，若不为空，我们便同样要进入循环，进行类似的操作。同学们对于这类较复杂的算法过程一定要手动进行模拟，不能光靠想。</p>
<ul>
<li>代码过程图示<img src="/.%5Cimgs%5Cimage-20230618104447464.png" alt="image-20230618104447464"></li>
</ul>
<table>
<thead>
<tr>
<th align="center">p指针的值</th>
<th align="center">当前访问结点</th>
<th align="center">当前栈的操作</th>
<th align="center">当前栈内元素（栈底-&gt;栈顶）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">A</td>
<td align="center">A入栈</td>
<td align="center">A</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">B</td>
<td align="center">B入栈</td>
<td align="center">A B</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">E</td>
<td align="center">E入栈</td>
<td align="center">ABE</td>
</tr>
<tr>
<td align="center">NULL</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">ABE</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center"></td>
<td align="center">E出栈</td>
<td align="center">AB</td>
</tr>
<tr>
<td align="center">NULL</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">AB</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center"></td>
<td align="center">B出栈</td>
<td align="center">A</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center">F</td>
<td align="center">F入栈</td>
<td align="center">AF</td>
</tr>
<tr>
<td align="center">NULL</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">AF</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center"></td>
<td align="center">F出栈</td>
<td align="center">A</td>
</tr>
<tr>
<td align="center">NULL</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">A</td>
</tr>
<tr>
<td align="center">A</td>
<td align="center"></td>
<td align="center">A出栈</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">C</td>
<td align="center">C入栈</td>
<td align="center">C</td>
</tr>
<tr>
<td align="center">H</td>
<td align="center">H</td>
<td align="center">H入栈</td>
<td align="center">CH</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
</tbody></table>
</li>
<li><p>中序非递归遍历: 中序非递归算法是在前面先序遍历非递归算法的基础上修改的,中序遍历顺序是左子树 根结点 右子树 所以需要将根结点及其左下结点依次进栈,但还不能访问,因为它的左子树没有遍历.当达到根结点的最左下结点时,它是中序序列的开始结点,也是栈顶节点,出栈并访问它,然后转向它的右子树,对右子树的处理与上述过程类似.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(biTree *T,Stack *s)</span> &#123;<span class="comment">//中序遍历</span></span><br><span class="line">	biTree *p = T;</span><br><span class="line">	<span class="type">bool</span> <span class="title function_">empty</span><span class="params">(Stack *)</span>;</span><br><span class="line">	<span class="type">bool</span> <span class="title function_">push</span><span class="params">(Stack *,biTree * )</span>;</span><br><span class="line">	biTree *<span class="title function_">top</span><span class="params">(Stack *)</span>;</span><br><span class="line">	<span class="type">bool</span> <span class="title function_">pop</span><span class="params">(Stack *)</span>;</span><br><span class="line">	<span class="keyword">while</span> (p||!empty(s)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p) &#123;<span class="comment">//一路向左</span></span><br><span class="line">			push(s,p);</span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p = top(s);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,p-&gt;data);<span class="comment">//打印栈顶元素</span></span><br><span class="line">			pop(s);<span class="comment">//栈顶元素出栈</span></span><br><span class="line">			p = p-&gt;rchild;<span class="comment">//向右寻找</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.%5Cimgs%5Cimage-20230618143327428.png" alt="image-20230618143327428"></p>
<table>
<thead>
<tr>
<th>p指针的值</th>
<th>当前访问结点</th>
<th>当前栈操作</th>
<th>当前栈内元素(栈底-&gt;栈顶)</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td></td>
<td>A入栈</td>
<td>A</td>
</tr>
<tr>
<td>B</td>
<td></td>
<td>B入栈</td>
<td>AB</td>
</tr>
<tr>
<td>E</td>
<td></td>
<td>E入栈</td>
<td>ABE</td>
</tr>
<tr>
<td>NULL</td>
<td></td>
<td></td>
<td>ABE</td>
</tr>
<tr>
<td>E</td>
<td>E</td>
<td>E出栈</td>
<td>AB</td>
</tr>
<tr>
<td>NULL</td>
<td></td>
<td></td>
<td>AB</td>
</tr>
<tr>
<td>B</td>
<td>B</td>
<td>B出栈</td>
<td>A</td>
</tr>
<tr>
<td>F</td>
<td></td>
<td>F入栈</td>
<td>AF</td>
</tr>
<tr>
<td>NULL</td>
<td></td>
<td></td>
<td>AF</td>
</tr>
<tr>
<td>F</td>
<td>F</td>
<td>F出栈</td>
<td>A</td>
</tr>
<tr>
<td>NULL</td>
<td></td>
<td></td>
<td>A</td>
</tr>
<tr>
<td>A</td>
<td>A</td>
<td>A出栈</td>
<td></td>
</tr>
<tr>
<td>C</td>
<td></td>
<td>C入栈</td>
<td>C</td>
</tr>
<tr>
<td>H</td>
<td></td>
<td>H入栈</td>
<td>CH</td>
</tr>
<tr>
<td>NULL</td>
<td></td>
<td></td>
<td>CH</td>
</tr>
<tr>
<td>H</td>
<td>H</td>
<td>H出栈</td>
<td>C</td>
</tr>
<tr>
<td>NULL</td>
<td></td>
<td></td>
<td>C</td>
</tr>
<tr>
<td>C</td>
<td>C</td>
<td>C出栈</td>
<td></td>
</tr>
<tr>
<td>NULL</td>
<td></td>
<td></td>
<td>程序结束</td>
</tr>
</tbody></table>
</li>
<li><p>后序非递归遍历:和前面两种非递归遍历一样的思路,我们知道后序遍历的顺序是左子树 右子树 根结点.所以先将根结点及其左下结点依次进栈,既是栈顶结点p的左子树以遍历或为空,仍还不能访问结点p,因为它们的右子树没有遍历,只有当这样的p结点的右子树已遍历完才能访问结点p. 由此过程我们可以知道后序遍历它的算法的视线难度是大于前两者的,因为它的限定条件更多。<br>现在我们来模拟一下下图的一个遍历流程<img src="/.%5Cimgs%5Cimage-20230618154012838.png" alt="image-20230618154012838"></p>
<p>首先A B E入栈，发现E没有左孩子也没有右孩子，输出E，E退栈，此时栈顶元素为B，访问B，发现B有右孩子,将右孩子F入栈,F同E,F输出并出栈,此时栈顶元素仍为B,但是我们刚刚将其右孩子已经输出,所以我们不再将其右孩子F入栈,直接输出B,此时栈顶元素为A,同样它存在右孩子且未被访问,所以我们要把其右孩子C入栈,这样不停循环,直至栈空…<br>这里就会比前两个遍历多出来一个问题需要我们进行考虑:我们如何判断栈顶元素的右孩子是否已经被访问呢?每当我们遇到问题的时候,我们首先应该去分析它的特点,然后根据其特点来制定相应的解决办法.我们可以发现,每当我们来到栈顶元素时,要么是从左孩子这边退回来,要么就是从右孩子这边退回来.也就是说,来到栈顶元素的前一个被访问的元素一定是它的孩子结点,现在我们的诉求是判断是否是栈顶元素的右孩子,那我们在每次访问输出结点时就将当前结点标记存储起来,当我需要退回到下一个栈顶元素时,我立马进行判断当前元素是否和我之前存储的结点相同,如果相同说明该栈顶元素的右子树已经被访问输出了,不用再管了,若不相同,说明其右子树需要进行遍历.下面给出示例代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">postOrder</span><span class="params">(biTree *T, Stack *s)</span> &#123;<span class="comment">//后序遍历</span></span><br><span class="line">	biTree *p = T;</span><br><span class="line">	biTree *r = (biTree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(biTree));</span><br><span class="line">	<span class="type">bool</span> <span class="title function_">empty</span><span class="params">(Stack *)</span>;</span><br><span class="line">	<span class="type">bool</span> <span class="title function_">push</span><span class="params">(Stack *, biTree *)</span>;</span><br><span class="line">	biTree *<span class="title function_">top</span><span class="params">(Stack *)</span>;</span><br><span class="line">	<span class="type">bool</span> <span class="title function_">pop</span><span class="params">(Stack *)</span>;</span><br><span class="line">	<span class="keyword">while</span> (p || !empty(s)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p) &#123;<span class="comment">//一路向左</span></span><br><span class="line">			push(s, p);</span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p = top(s);</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;rchild&amp;&amp;r != p-&gt;rchild) &#123;</span><br><span class="line">				p = p-&gt;rchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, p-&gt;data);<span class="comment">//打印栈顶元素</span></span><br><span class="line">				r = p;<span class="comment">//r作为暂存指针,用以后续的右孩子判断</span></span><br><span class="line">				pop(s);<span class="comment">//栈顶元素出栈</span></span><br><span class="line">				p = <span class="literal">NULL</span>;<span class="comment">//这里一定要将p设为NULL，因为p的孩子已经遍历过了，不设置为NUll的话，又会将左孩子压入栈</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面模拟上图的代码模拟流程:</p>
<table>
<thead>
<tr>
<th>p指针的值</th>
<th>r指针的值</th>
<th>当前访问元素</th>
<th>当前栈操作</th>
<th>当前栈内元素</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>NULL</td>
<td></td>
<td>A入栈</td>
<td>A</td>
</tr>
<tr>
<td>B</td>
<td>NULL</td>
<td></td>
<td>B入栈</td>
<td>AB</td>
</tr>
<tr>
<td>E</td>
<td>NULL</td>
<td></td>
<td>E入栈</td>
<td>ABE</td>
</tr>
<tr>
<td>NULL</td>
<td>NULL</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E(没有右孩子)</td>
<td>NULL</td>
<td>E</td>
<td>E出栈</td>
<td>AB</td>
</tr>
<tr>
<td>NULL</td>
<td>E</td>
<td></td>
<td></td>
<td>AB</td>
</tr>
<tr>
<td>B</td>
<td>E</td>
<td></td>
<td></td>
<td>AB</td>
</tr>
<tr>
<td>F</td>
<td>E</td>
<td></td>
<td>F入栈</td>
<td>ABF</td>
</tr>
<tr>
<td>NULL</td>
<td>E</td>
<td></td>
<td></td>
<td>ABF</td>
</tr>
<tr>
<td>F(没有右孩子)</td>
<td>F</td>
<td>F</td>
<td>F出栈</td>
<td>AB</td>
</tr>
<tr>
<td>B(右孩子与r同)</td>
<td>F</td>
<td>B</td>
<td>B出栈</td>
<td>A</td>
</tr>
<tr>
<td>A(右孩子不等于r,继续向右遍历)</td>
<td>B</td>
<td></td>
<td></td>
<td>A</td>
</tr>
<tr>
<td>C</td>
<td>B</td>
<td></td>
<td>C入栈</td>
<td>AC</td>
</tr>
<tr>
<td>H</td>
<td>B</td>
<td></td>
<td>H入栈</td>
<td>ACH</td>
</tr>
<tr>
<td>NULL</td>
<td>B</td>
<td></td>
<td></td>
<td>ACH</td>
</tr>
<tr>
<td>H(没有右孩子)</td>
<td>B</td>
<td>H</td>
<td>H出栈</td>
<td>AC</td>
</tr>
<tr>
<td>C(没有右孩子)</td>
<td>H</td>
<td>C</td>
<td>C出栈</td>
<td>A</td>
</tr>
<tr>
<td>A(右孩子与r同)</td>
<td>C</td>
<td>A</td>
<td>A出栈</td>
<td>程序结束</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>层次遍历：所谓层次遍历，就是按照视觉上一层一层的去进行遍历，如该图<img src="/.%5Cimgs%5Cimage-20230618161939603.png" alt="image-20230618161939603"></p>
<p>层次遍历序列为：ABCEFH<br>我们可以发现，先访问的结点的左右孩子也要先进行访问，这与队列的特征相吻合，因此层次遍历可以采用队列来实现</p>
<p>层次遍历的过程是：先将根结点入队，在队不空时循环，从队列中出列一个结点p，访问它。若它有左孩子节点，将左孩子节点进队；若它有右孩子结点，将右孩子结点入队。如此操作直到队空为止。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">levelOrder</span><span class="params">(biTree *T,Squeue *sq,<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">	biTree *p = T;<span class="comment">//工作指针</span></span><br><span class="line">	biTree *r = ( biTree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>( biTree));<span class="comment">//暂存指针</span></span><br><span class="line">	<span class="type">bool</span> <span class="title function_">enQueue</span><span class="params">(Squeue *, biTree *, <span class="type">int</span>)</span>;</span><br><span class="line">	<span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Squeue *)</span>;</span><br><span class="line">	<span class="type">bool</span> <span class="title function_">deQueue</span><span class="params">(Squeue *, biTree **,<span class="type">int</span>)</span>;</span><br><span class="line">	enQueue(sq,p,maxSize);<span class="comment">//根节点入队</span></span><br><span class="line">	<span class="keyword">while</span> (!isEmpty(sq)) &#123;</span><br><span class="line">		deQueue(sq,&amp;r,maxSize);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,r-&gt;data);</span><br><span class="line">		<span class="keyword">if</span>(r-&gt;lchild)enQueue(sq, r-&gt;lchild, maxSize);</span><br><span class="line">		<span class="keyword">if</span> (r-&gt;rchild)enQueue(sq, r-&gt;rchild, maxSize);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="二叉树的基本运算"><a href="#二叉树的基本运算" class="headerlink" title="二叉树的基本运算"></a>二叉树的基本运算</h3><ul>
<li><p>创建二叉树:大家想想我们在手画一颗二叉树的步骤,是不是先画出根结点,然后画出分支,再画出其孩子结点.如此循环往复.其实所有的算法代码都是我们实际问题的模拟.我们先画的根结点,那我们就采取先序遍历来创建出一颗二叉树.我们之前学习过先序遍历的递归代码,现在老师带领你们看看如何将最基本的递归遍历代码改造为创建一颗二叉树的代码.<br>首先,先序遍历的代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序递归遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(biTree* T)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, T-&gt;data);</span><br><span class="line">		preOrder(T-&gt;lchild);</span><br><span class="line">		preOrder(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们应该由用户输入结点的值,我们应该由输入值来判断是否需要创建该结点,也就是需要一个条件用于退出递归,如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">biTree* <span class="title function_">create</span><span class="params">(<span class="type">int</span> type)</span> &#123;<span class="comment">//这里我们采用先序创建一颗二叉树，type为节点类型：0代表int 1代表char</span></span><br><span class="line">	biTree* T = <span class="literal">NULL</span>;</span><br><span class="line">	BNODETYPE data;</span><br><span class="line">	type ? <span class="built_in">printf</span>(<span class="string">&quot;请输入当前节点值(char)：data=&quot;</span>) : <span class="built_in">printf</span>(<span class="string">&quot;请输入当前节点值(int)：data=&quot;</span>);</span><br><span class="line">	type ? <span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;data) : <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);<span class="comment">//</span></span><br><span class="line">	<span class="keyword">if</span> (data != <span class="string">&#x27;#&#x27;</span> &amp;&amp; data != <span class="number">-1</span>) &#123;</span><br><span class="line">		T = (biTree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(biTree));</span><br><span class="line">		T-&gt;data = data;</span><br><span class="line">		T-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">		T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">		T-&gt;lchild = create(type);</span><br><span class="line">		T-&gt;rchild = create(type);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到,在第6行,我们会对用户输入的数据进行判定,我们人为规定,当用户输入”#”或”-1”时,代表当前结点为空,直接返回,作为上一层递归的结点的孩子.当输入不为其中之一时,代表这是一个实实在在的结点,我们应为其分配空间,并将数据域赋值为输入的值.如此递归下去,直至程序结束.</p>
</li>
<li><p>销毁二叉树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">destoryBTree</span><span class="params">(biTree *T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        destoryBTree(T-&gt;lchild);</span><br><span class="line">        destoryBTree(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">free</span>(T)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计结点个数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计节点个数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nodeNum</span><span class="params">(biTree* T, <span class="type">int</span>* num)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		(*num)++;<span class="comment">//注意这里++的优先级高于*，要加上括号</span></span><br><span class="line">		nodeNum(T-&gt;lchild, num);</span><br><span class="line">		nodeNum(T-&gt;rchild, num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求结点值为x的层次</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求结点值为x的层次</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">getXLevel</span><span class="params">(biTree* T, <span class="type">int</span> x, <span class="type">int</span>&amp; level, <span class="type">int</span> count)</span> &#123;<span class="comment">//level获取最终的层次，count用于计数</span></span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (T-&gt;data == x)<span class="comment">//相等时，层次确定</span></span><br><span class="line">			level = count;</span><br><span class="line">		getXLevel(T-&gt;lchild, x, level, count + <span class="number">1</span>);<span class="comment">//每往下寻找，count便加一</span></span><br><span class="line">		getXLevel(T-&gt;rchild, x, level, count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求树的高度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getHigh</span><span class="params">(biTree *T)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (!T)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> lDepth = getHigh(T-&gt;lchild);</span><br><span class="line">	<span class="type">int</span> rDepth = getHigh(T-&gt;rchild);</span><br><span class="line">	<span class="type">int</span> depth = lDepth &gt; rDepth ? lDepth+<span class="number">1</span> : rDepth+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> depth;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求指定值为x的结点的双亲结点p</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求指定值为x的结点的双亲结点p</span></span><br><span class="line">biTree* <span class="title function_">findParent</span><span class="params">(biTree* T, <span class="type">int</span> x)</span> &#123;<span class="comment">//采用先序递归遍历</span></span><br><span class="line">	<span class="type">static</span> biTree* pre = <span class="literal">NULL</span>;<span class="comment">//设立一个先驱结点</span></span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		<span class="keyword">if</span> (T-&gt;data != x) &#123;<span class="comment">//当前结点不等于x，先驱更新</span></span><br><span class="line">			pre = T;</span><br><span class="line">		&#125;</span><br><span class="line">		findParent(T-&gt;lchild, x);</span><br><span class="line">		findParent(T-&gt;rchild, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="二叉树的构造"><a href="#二叉树的构造" class="headerlink" title="二叉树的构造"></a>二叉树的构造</h3><p>我们在这个小节假设二叉树的每个结点值为单个字符,而且所有结点值均不相同,同一颗二叉树具有唯一的先序序列&#x2F;中序序列和后序序列,但不同的二叉树可能具有相同的先序序列&#x2F;中序序列和后序序列<img src="/.%5Cimgs%5Cimage-20230620142956081.png" alt="image-20230620142956081"></p>
<p><img src="/.%5Cimgs%5Cimage-20230620143139571.png" alt="image-20230620143139571"></p>
<p><img src="/.%5Cimgs%5Cimage-20230620143257732.png" alt="image-20230620143257732"></p>
<ul>
<li>定理1:任何n(n≥0)个不同结点的二叉树,都可由它的中序序列和先序序列唯一地确定.</li>
<li>定理2:任何n(n≥0)个不同结点的二叉树,都可由它的中序序列和后序序列唯一地确定.<ul>
<li>常考题型:给出先序和中序画出二叉树;给出后序和中序画出二叉树;给出层序和中序画出二叉树</li>
<li>例:先序 ABDEGCF  中序 DBEGACF 画出这颗二叉树<img src="/.%5Cimgs%5Cimage-20230620155219274.png" alt="image-20230620155219274"></li>
</ul>
</li>
</ul>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><ul>
<li><p>概念:遍历二叉树的结果是得到一个所有结点的线性序列,无论是先序、中序还是后序，都使得所得序列中的每个结点（除了第一个结点和最后一个结点）都有一个直接前驱和一个直接后继。<br>为使其可以向链表一样可以轻松的得到结点的前驱与后继，我们很容易就想到利用二叉树中的空指针域用于存储前驱和后继信息。具体规则如下：<br>当某结点的左指针为空时，令该指针指向这个线性序列中该结点的前驱结点；当某结点的右指针为空时，令该指针指向这个序列中该结点中的后继结点，这样的指向该线性序列中的“前驱结点”和“后继结点”的指针称为“线索”。创建线索的过程称为线索化，拥有线索的二叉树称为线索二叉树。</p>
<p>大家需要思考一个问题，我们将空指针域作为一条线索存在，这是人为的定义，而在代码中的实现计算机仍然将它当做是左右孩子，所以我们必须得使用一些特殊的标记来让计算机明白什么时候是指针、什么时候是线索。这就引出了标志域tag。在二叉树结点结构中新增两个属性：ltag和rtag</p>
<p>$ 左标志ltag&#x3D;\begin{cases} 0 \quad表示lchild指向左孩子结点\ 1\quad 表示lchild指向前驱结点\end{cases}$</p>
<p>$ 右标志ltag&#x3D;\begin{cases} 0 \quad表示lchild指向右孩子结点\ 1\quad 表示lchild指向后继结点\end{cases}$</p>
<p>增加了标志域的结点的存储结构如下:</p>
<table>
<thead>
<tr>
<th>ltag</th>
<th>lchild</th>
<th>data</th>
<th>rchild</th>
<th>rtag</th>
</tr>
</thead>
</table>
<p>增加了标志域的结点结构体如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">biTree</span> &#123;</span></span><br><span class="line">	BNODETYPE data;</span><br><span class="line">	biTree* lchild;</span><br><span class="line">	biTree* rchild;</span><br><span class="line">	<span class="type">int</span> ltag, rtag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线索化二叉树:建立一颗线索二叉树,其实就是通过遍历将空指针域进行重新指向前驱或者后继的过程。<img src="/.%5Cimgs%5Cimage-20230620165010205.png" alt="image-20230620165010205"></p>
</li>
<li><p>线索二叉树的代码实现（以中序线索二叉树为例）</p>
<ul>
<li><p>中序线索二叉树是在已有二叉树的基础上通过中序遍历添加线索而得到，在遍历过程中，如果当前结点左孩子指针为空，则需要将其作为左线索，将其指向其前驱，而在我们定义的结点结构中并没有指向结点前驱的属性变量，所以我们需要在代码中时刻保持存储当前遍历结点的前驱结点，即我们初始化一个指针变量pre&#x3D;NULL，该指针变量会随着结点的变动而变动，pre会一直是当前结点的前驱结点；另一方面，我们就可以去处理pre指针指向的结点的右孩子指针域，如果pre指针不指向空，并且其右孩子指针为空，说明该指针域可以作为线索存在，从而将该指针域指向其后继结点，即当前遍历结点。这样，我们就可以得到一颗中序线索二叉树。代码如下：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> biTree* pre = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">inThread</span><span class="params">(biTree *p )</span> &#123;<span class="comment">//中序线索二叉树</span></span><br><span class="line">	<span class="keyword">if</span> (p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">		inThread(p-&gt;lchild);</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;lchild==<span class="literal">NULL</span>) &#123;<span class="comment">//如果左子树为空，建立前驱线索</span></span><br><span class="line">			p-&gt;lchild = pre;</span><br><span class="line">			p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild==<span class="literal">NULL</span>) &#123;<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">			pre-&gt;rchild = p;</span><br><span class="line">			pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pre = p;</span><br><span class="line">		inThread(p-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h3><ul>
<li><p>哈夫曼树概述:在许多应用中经常将树中的结点赋予一个有某种意义的数值,称此数值为该结点的权.从根结点到该结点之间的路径长度与该结点上的权的乘积称为结点的带权路径长度.树中所有叶子结点的带权路径长度之和称为概述的带权路径长度,通常记为:<br>$$<br>WPL&#x3D;\sum_{i&#x3D;1}^{n_0}w_il_i<br>$$<br>其中,$n_0$ 表示叶子结点的个数,$w_i和l_i$分别表示第$i$个叶子结点的权值和根到它之间的路径长度(即从根结点到该叶子结点的路径上经过的分支数).</p>
<p>在$n_0$个带权叶子结点构成的所有二叉树中,带权路径长度WPL最小的二叉树称为哈夫曼树或最优二叉树.如下面的带权二叉树,它们的带权路径长度<br>$$<br>\begin{cases}(a)WPL&#x3D;1\times2+4\times3+5\times3+6\times3&#x3D;47\<br>         (b)WPL&#x3D;1\times3+4\times3+5\times2+6\times1&#x3D;31\<br>         (c)WPL&#x3D;1\times2+4\times2+5\times2+6\times2&#x3D;32\\end{cases}<br>$$</p>
<p><img src="/.%5Cimgs%5Cimage-20230620192311135.png" alt="image-20230620192311135"></p>
<p>显而易见,对于一组具有确定权值的叶子结点可以构造出多个具有不同带权路径长度的二叉树.也同样可以发现,b图是一颗哈夫曼树,它的带权路径长度最小.</p>
</li>
<li><p>哈夫曼树的构造:在哈夫曼树的构造中,一般会给出n个带有给定权值的结点,要求我们通过一定的算法将这n个结点构造成一颗二叉树,且这n个结点最后都是叶子结点,并且带权路径长度WPL最小.下面给出一般的构造哈夫曼树的算法步骤:</p>
<p>(1)根据给定的n个权值($\omega_1,\omega_2,…\omega_n,$),对应结点构成n棵二叉树的森林$F&#x3D;(T_1,T_2,…,T_n)$ ,其中每颗二叉树$T_i(1\leq i\leq n)$,中都只有一个带权值为$\omega_i$ 的根结点,其左右子树均为空.</p>
<p>(2)在森林F中选取两颗结点的权值最小的子树分别作为左右子树构造一颗新的二叉树,并且置新的二叉树的根结点的权值为其左右子树上根的权值之和.</p>
<p>(3)在森林F中,用新得到的二叉树代替这两棵树</p>
<p>(4)重复(2)和(3),直到F只含一棵树为止.这棵树便是哈夫曼树</p>
</li>
<li><p>下面给出一个示例:<img src="/imgs/image-20230629122749827.png" alt="image-20230629122749827"></p>
</li>
<li><p>定理1：对于具有$n_0$个叶子结点的哈夫曼树，共有$2n_0-1$个结点。</p>
<p>证明:在哈夫曼树的构造过程中，每次都是将两颗树合并为一棵树，所以哈夫曼树中不存在度为1的节点，即$n_1 &#x3D; 0$ . 由二叉树的性质可知，$n_0&#x3D;n_2+1$ ,即$n_2 &#x3D; n_0 -1 ,则 n &#x3D; n_0 +n_1 +n_2 &#x3D; n_0 +n_2 &#x3D; n_0 +n_0 -1 &#x3D; 2n_0 -1$.</p>
</li>
<li><p>哈夫曼树的结点类型定义：我们要清楚,结点的结构体的构建都是为了我们更好地去表述相应的构造算法,所以在这里我们要从算法的角度去分析结构体的构造.</p>
<p>大家可以想一想,在这里哈夫曼树应该用什么样的存储结构来表示呢?还是和之前二叉树那样链接的方式吗?显然不恰当,因为我们会重复利用这里由两个最小权值结点之和形成的新的结点,所以我们有双亲结点指向孩子结点的”指针”,而我们的哈夫曼编码是需要去判断当前结点是其双亲结点的左孩子亦或右孩子,一般而言,左孩子编码”0”,右孩子编码”1”.这样的话我们就必须有从孩子结点指向双亲的”指针”.也就是说一般性的二叉树的无法满足我们这里的要求.</p>
<p>在这里,我们设计一种新的结构体:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> N 30						<span class="comment">//叶子结点数的最大值</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> M 2 * N - 1				<span class="comment">//所有结点数的最大值</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX 32767</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*哈夫曼树的类型定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> data;						<span class="comment">//存放结点字符</span></span><br><span class="line">	<span class="type">int</span> weight;						<span class="comment">//结点的权值</span></span><br><span class="line">	<span class="type">int</span> parent;						<span class="comment">//双亲的下标</span></span><br><span class="line">	<span class="type">int</span> LChild;						<span class="comment">//左孩子结点的下标</span></span><br><span class="line">	<span class="type">int</span> RChild;						<span class="comment">//右孩子结点的下标</span></span><br><span class="line">&#125;HTNode, HuffmanTree[M + <span class="number">1</span>];		<span class="comment">//HuffmanTree是一个结构数组类型，0号单元不用</span></span><br></pre></td></tr></table></figure>

<p>如上代码所示:在这个哈夫曼树结点结构体的构成中包含着结点本身的信息、结点的权值、结点的双亲下标、及其左右孩子的下标。这样我们就可以进行构造算法的设计了。</p>
</li>
<li><p>哈夫曼树的构造算法：这里先贴出哈夫曼树的构造代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*哈夫曼树及哈夫曼编码实现*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> N 30						<span class="comment">//叶子结点数的最大值</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> M 2 * N - 1				<span class="comment">//所有结点数的最大值</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX 32767</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*哈夫曼树的类型定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> data;						<span class="comment">//存放结点字符</span></span><br><span class="line">	<span class="type">int</span> weight;						<span class="comment">//结点的权值</span></span><br><span class="line">	<span class="type">int</span> parent;						<span class="comment">//双亲的下标</span></span><br><span class="line">	<span class="type">int</span> LChild;						<span class="comment">//左孩子结点的下标</span></span><br><span class="line">	<span class="type">int</span> RChild;						<span class="comment">//右孩子结点的下标</span></span><br><span class="line">&#125;HTNode, HuffmanTree[M + <span class="number">1</span>];		<span class="comment">//HuffmanTree是一个结构数组类型，0号单元不用</span></span><br><span class="line"></span><br><span class="line">HuffmanTree ht;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在ht[1]至ht[n]的范围内选择两个parent为0且weight最小的结点，其序号分别赋给s1，s2*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Select</span><span class="params">(HuffmanTree ht, <span class="type">int</span> n, <span class="type">int</span>* s1, <span class="type">int</span>* s2)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i, min1 = MAX, min2 = MAX;</span><br><span class="line">	*s1 = <span class="number">0</span>;</span><br><span class="line">	*s2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ht[i].parent == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ht[i].weight &lt; min1) &#123;</span><br><span class="line">				min2 = min1;</span><br><span class="line">				*s2 = *s1;</span><br><span class="line">				min1 = ht[i].weight;</span><br><span class="line">				*s1 = i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ht[i].weight &lt; min2) &#123;</span><br><span class="line">				min2 = ht[i].weight;</span><br><span class="line">				*s2 = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建哈夫曼树算法*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CrtHuffmanTree</span><span class="params">(HuffmanTree ht, <span class="type">int</span> w[],<span class="type">char</span> data[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="comment">//构造哈夫曼树ht[M+1],w[]存放n个权值</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;		<span class="comment">//1至n号单元存放叶子结点，初始化</span></span><br><span class="line">		ht[i].data = data[i - <span class="number">1</span>];</span><br><span class="line">		ht[i].weight = w[i - <span class="number">1</span>];</span><br><span class="line">		ht[i].parent = <span class="number">0</span>;</span><br><span class="line">		ht[i].LChild = <span class="number">0</span>;</span><br><span class="line">		ht[i].RChild = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m = <span class="number">2</span> * n - <span class="number">1</span>;				<span class="comment">//所有结点总数</span></span><br><span class="line">	<span class="keyword">for</span> (i = n + <span class="number">1</span>; i &lt;= m; i++) &#123;	<span class="comment">//n+1至m号单元存放非叶结点，初始化</span></span><br><span class="line">		ht[i].data = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">		ht[i].weight = <span class="number">0</span>;</span><br><span class="line">		ht[i].parent = <span class="number">0</span>;</span><br><span class="line">		ht[i].LChild = <span class="number">0</span>;</span><br><span class="line">		ht[i].RChild = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化完毕，开始创建非叶结点*/</span></span><br><span class="line">	<span class="type">int</span> s1, s2;<span class="comment">//当前最小两值的序号</span></span><br><span class="line">	<span class="keyword">for</span> (i = n + <span class="number">1</span>; i &lt;= m; i++) &#123;	<span class="comment">//创建非叶结点，建哈夫曼树</span></span><br><span class="line">		Select(ht, i - <span class="number">1</span>, &amp;s1, &amp;s2);<span class="comment">//在ht[1]至ht[i-1]的范围内选择两个parent为0且weight最小的结点，其序号分别赋给s1，s2</span></span><br><span class="line">		ht[i].weight = ht[s1].weight + ht[s2].weight;</span><br><span class="line">		ht[s1].parent = i;</span><br><span class="line">		ht[s2].parent = i;</span><br><span class="line">		ht[i].LChild = s1;</span><br><span class="line">		ht[i].RChild = s2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*哈夫曼编码*/</span>	</span><br><span class="line"><span class="type">void</span> <span class="title function_">CrtHuffmanCode</span><span class="params">(HuffmanTree ht, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="comment">//从叶子结点到根，逆向求每个叶子结点(共n个)对应的哈夫曼编码</span></span><br><span class="line">	<span class="type">char</span>* cd;</span><br><span class="line">	cd = (<span class="type">char</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">char</span>));	<span class="comment">//分配当前编码的工作空间</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;			<span class="comment">//求n个叶子结点对应的哈夫曼编码</span></span><br><span class="line">		<span class="type">int</span> start = n - <span class="number">1</span>, c = i, p = ht[i].parent;</span><br><span class="line">		<span class="keyword">while</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">			--start;</span><br><span class="line">			<span class="keyword">if</span> (ht[p].LChild == c)			<span class="comment">//左分支标0</span></span><br><span class="line">				cd[start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cd[start] = <span class="string">&#x27;1&#x27;</span>;			<span class="comment">//右分支标1</span></span><br><span class="line">			c = p;							<span class="comment">//向上倒堆</span></span><br><span class="line">			p = ht[p].parent;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c的编码：&quot;</span>, ht[i].data);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cd[j] == <span class="string">&#x27;0&#x27;</span> || cd[j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, cd[j]);		<span class="comment">//编码输出</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		<span class="built_in">memset</span>(cd, <span class="number">-1</span>, n);<span class="comment">//将cd初始化</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i, w[<span class="number">5</span>] = &#123; <span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span> &#125;;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">5</span>] = &#123; <span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;t&#x27;</span> &#125;;</span><br><span class="line">	CrtHuffmanTree(ht, w, str,<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;哈夫曼树各结点值：\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, ht[i].data);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	CrtHuffmanCode(ht, <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明:在一组字符的哈夫曼编码中,任一字符的哈夫曼编码不可能是另一字符哈夫曼码的前缀.</p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集:"></a>并查集:</h2><ul>
<li><p>什么是并查集:所谓并查集，是用来解决元素分组问题的一种数据结构，主要有两个功能：合并两个不相交集合、查询两个元素是否在同一个集合中。也正因为是这两个功能，所以该数据结构叫做并查集。</p>
</li>
<li><p>形象地理解并查集：并查集的重要思想就在于要用集合中的一个元素来代表集合。就好比把集合比喻成帮派，而代表元素则是帮主。我们利用这个比喻来看看并查集是如何运作的。</p>
<ul>
<li><p><img src="/imgs/image-20230703211222186.png" alt="image-20230703211222186"></p>
<p>初始状态，所有人自成一派，自己就是帮主（对于只有一个元素的集合，代表元素自然也只能是那个唯一的元素）</p>
</li>
<li><p>现在，1号与4号进行比武，假设1号赢，那么按照江湖规矩，4号就得当1号的小弟（合并），此时1号帮派就有两个人了，帮主（代表元素就是1号）<img src="/imgs/image-20230703211628067.png" alt="image-20230703211628067"></p>
</li>
<li><p>过了一段时间，5号选手想和想和4号pk，首先他们得看看他们得帮主是不是同一个人，如果是同一个人那就不能开战，发现不是同一人，5号的帮主就是他自己，而4号帮主是1号，1号出马迎接5号的挑战，假设仍然1号胜出，那么5号也必须加入1号帮派，1号仍然作为帮主。<img src="/imgs/image-20230703212003332.png" alt="image-20230703212003332"></p>
</li>
<li><p>假设2 3 6 号也同样进行了激烈的帮派斗争，形成以下格局<img src="/imgs/image-20230703212234571.png" alt="image-20230703212234571"></p>
</li>
<li><p>现在江湖上形成了两强局面，某一天4号和6号想要pk。首先他们的帮主不是同一人，所以他们喊各自的帮主，1号和3号出手，假设1号胜利，则3号拜入1号门下，当然2号和6号作为3号小弟也成为了1号的小弟。</p>
</li>
</ul>
<p><img src="/imgs/image-20230703212849778.png" alt="image-20230703212849778"></p>
<ul>
<li><p>善于观察的同学已经发现这其实是一个树状的结构，要寻找集合的代表元素，只需要一步一步的向上寻找即可，可以发现，代表元素的箭头是永远指向自己的，这也是我们去判断是否找到代表元素的一个条件。<img src="/imgs/image-20230703213253141.png" alt="image-20230703213253141"></p>
</li>
<li><p>并查集代码： 我们上面的描述可以知道，我们的每一个结点都要能够找到他的双亲结点，而且最开始的祖先结点就是结点本身。鉴于此我们可以设置一个数组用来达到此目的，即将数组下标代表各元素，而下标对应的值为其双亲序号，这样层层寻找就可以找到其祖先元素。由此并查集代码实现可分为以下三个部分：</p>
<ul>
<li><p>初始化一个并查集</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="type">int</span> *fa = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*G-&gt;numV);<span class="comment">//并查集数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;numV; i++) &#123;</span><br><span class="line">		fa[i] = i;<span class="comment">//最开始将每个节点的祖先设置为自己</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> fa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>查找祖先元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findAncestor</span><span class="params">(<span class="type">int</span> *fa, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (fa[i] == i)<span class="keyword">return</span> i;<span class="comment">//找到返回</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> findAncestor(fa,fa[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并两个集合，即将两个“帮主”进行合并,即将前者的父节点设为后者即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unionn</span><span class="params">(<span class="type">int</span> *fa, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i_a = findAncestor(fa, i);</span><br><span class="line">	<span class="type">int</span> j_a = findAncestor(fa, j);</span><br><span class="line">	fa[i_a] = j_a;<span class="comment">//i的祖先指向j的祖先</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>路径压缩：上面的并查集的效率是比较低的，例如，如果我们遇到了下面的场景：<img src="/imgs/image-20230704205709373.png" alt="image-20230704205709373"></p>
<ul>
<li><p>在合并2,3 时，我们找到2 的祖先是1，然后将1的祖先设置为3，同理第二步时将3的祖先设置为4.大家可以发现,这样的一种做法会使得我们的查询效率变得十分低下,假如有10000个数,那么最大的查找次数就会为10000次.而我们也可以发现,我们的目的是找到”代表元素”,那直观地来看,我们完全可以将我的父亲节点直接设置为”代表元素”,就像这样：<img src="/imgs/image-20230704210556316.png" alt="image-20230704210556316"></p>
<p>这样我们每次就可以以0(1)的时间复杂度找到我们的“代表元素”。这种方法也叫做路径压缩，现在我们看看代码应该如何实现，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findAncestor</span><span class="params">(<span class="type">int</span> *fa, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (fa[i] == i)<span class="keyword">return</span> i;<span class="comment">//找到返回</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">        fa[i]=findAncestor(fa,fa[i]);<span class="comment">//父节点设为“代表元素”</span></span><br><span class="line">		<span class="keyword">return</span> fa[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述代码也可以进行简化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findAncestor</span><span class="params">(<span class="type">int</span> *fa, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fa[i]==i ? i: ( fa[i]=findAncestor(fa,fa[i]));</span><br><span class="line">	<span class="comment">//三元运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第五章：图"><a href="#第五章：图" class="headerlink" title="第五章：图"></a>第五章：图</h2><h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><ul>
<li><p>定义：<br>图是由两个集合，顶点集V(vertex)和边集E(edge)组成，记为G&#x3D;(V，E)，其中，V(G)是图中顶点的有限集合，E(G)是图中两个顶点连接形成的边的有限集合。</p>
<p><em>注：在我们的这些数据结构中，线性表可以使空表，树也可以是空树，但是图不能是空图，至少得有一个顶点，图中可以没有边</em></p>
</li>
<li><p>分类</p>
<ul>
<li><p>有向图</p>
<ul>
<li>有向边（弧）的有限集合<ul>
<li><p>弧是顶点的有序对</p>
</li>
<li><p>&lt;v,w&gt;</p>
</li>
<li><p>v是弧尾，w是弧头</p>
</li>
<li><p>v邻接到w或w邻接自v</p>
<p><img src="/imgs/image-20230704223355193.png" alt="image-20230704223355193"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>无向图</p>
<ul>
<li>无向边的有限集合<ul>
<li><p>边是顶点的无序对</p>
</li>
<li><p>（v,w）</p>
</li>
<li><p>（v,w）&#x3D;(w,v)</p>
</li>
<li><p>w，v互为邻接点</p>
<p><img src="/imgs/image-20230704223508076.png" alt="image-20230704223508076"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>简单图</p>
<ul>
<li><p>1.不存在顶点到自身的边</p>
</li>
<li><p>2.同一条边不重复出现</p>
<p><img src="/imgs/image-20230704223711208.png" alt="image-20230704223711208"></p>
</li>
</ul>
</li>
<li><p>多重图</p>
<ul>
<li><p>若图G中某两个结点之间的边数多于一条，又允许顶点通过同一个边和自己关联，也就是自环</p>
<p><img src="/imgs/image-20230704223836795.png" alt="image-20230704223836795"></p>
</li>
</ul>
</li>
<li><p>完全图</p>
<ul>
<li><p>无向完全图</p>
<ul>
<li><p>任意两个顶点之间都存在边，对于无向完全图，包含$n(n-1)&#x2F;2$条边。</p>
<p><img src="/imgs/image-20230704223711208.png" alt="image-20230704223711208"></p>
</li>
</ul>
</li>
<li><p>有向完全图</p>
<ul>
<li><p>如果任意两个顶点之间都存在方向相反的两条弧，对于有向完全图，包含$n(n-1)$条边</p>
<p><img src="/imgs/image-20230704224745816.png" alt="image-20230704224745816"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>子图</p>
<ul>
<li><p>设有两个图G&#x3D;(V,E)和G1&#x3D;(V1,E1),若V1是V的子集,E1是E的子集,则称G1是G的子图.</p>
<p>  <em>注:子图首先一定得是个图,也就是说,随便地从G中取出顶点和边不一定就是子图的</em></p>
<p>  <img src="/imgs/image-20230704225247689.png" alt="image-20230704225247689"></p>
</li>
</ul>
</li>
<li><p>连通 连通图 与连通分量:</p>
<ul>
<li>连通:在无向图中,若从顶点m到顶点n存在路径,则称顶点m和顶点n是连通的</li>
<li>连通图:若图中任意两个顶点之间均有路径,则称该图为连通图</li>
<li>连通分量:无向图中的极大连通子图成为该图的连通分量<ul>
<li>极大:代表在子图中顶点足够多,依附的边也足够多.</li>
<li>显然一个连通图的极大连通子图就是它本身</li>
<li>非连通图存在多个连通分量</li>
<li>找连通分量的方法：<br>  从选取一个顶点开始，以这个顶点作为一个子图，然后逐个添加与这个子图相连的顶点和边直到所有相连的顶点都加入该子图</li>
</ul>
</li>
</ul>
</li>
<li><p>强连通图和强连通分量:</p>
<ul>
<li><p>强连通图:在有向图中,若图中任意顶点之间都是连通的,则称该有向图是强连通图</p>
</li>
<li><p>强连通分量:有向图中的极大强连通子图称为该有向图的强连通分量</p>
<ul>
<li><p>找强连通分量:</p>
<p>  (1) 在图中找有向环</p>
<p>  (2)扩展该有向环:如果某个顶点到该环中的任一顶点有路径,并且该环中的任一顶点到这个顶点也有路径,则加入这个顶点.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>连通图的生成树：包含图中全部n个顶点，但是只有n-1条边的极小连通子图</p>
<ul>
<li>生成树去掉一条边则变成非连通图，加上一条边就会形成回路。</li>
</ul>
</li>
<li><p>度：以该顶点为一个端点的边数目</p>
<ul>
<li>无向图中顶点V的度是指依附于该顶点的边的条数，记为TD(v)</li>
<li>有向图中顶点V的度分为出度和入度<ul>
<li>入度（ID）是以顶点v为终点的有向边的数目</li>
<li>出度（OD）是以顶点V为起点的有向边的数目</li>
</ul>
</li>
</ul>
</li>
<li><p>简单路径和简单回路：顶点不重复出现的路径称为简单路径。对于回路，除了第一个和最后一个顶点其余顶点不重复出现的回路称为简单回路</p>
</li>
<li><p>权和网：图中每条边考研赋予一定意义的数值，这个数值叫做这条边的权，有权值得图称为带权图，也叫做网</p>
</li>
<li><p>路径和路径长度：顶点p到q之间的路径是指顶点序列怕保存的，p,a,b,c,d,……q。路径上边的数目就是路径长度</p>
</li>
<li><p>回路（环）：第一个和最后一个顶点相同的路径称为回路或者环</p>
</li>
<li><p>距离：从顶点u到v的最短路径长度。不存在路径则为无穷</p>
</li>
</ul>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><ul>
<li><p>邻接矩阵（顺序存储）</p>
<ul>
<li><p>图的邻接矩阵是一种采用邻接矩阵数组表示顶点之间相邻关系的存储结构。邻接矩阵说白了就是一个二维数组，数组下标代表顶点序号，数组值，即行列交叉处代表两个顶点之间的权值，如果是无权图，那么我们简单设置为1即可。如果两顶点之间没有边，那我们就可以将数组对应位置设置为$\infty$ 或者0都可以。</p>
</li>
<li><p>不带权无向图</p>
<p>  <img src="/imgs/image-20230704223508076.png" alt="image-20230705164852108"></p>
<p>  对于上面的无向图所对应的邻接矩阵为：</p>
<p>  <img src="/imgs/%E7%94%BB%E5%B8%83/%E6%97%A0%E5%90%91%E5%9B%BE%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png"></p>
</li>
<li><p>不带权有向图：<img src="/imgs/image-20230704223355193.png"></p>
<p>  邻接矩阵<img src="/imgs/%E4%B8%8D%E5%B8%A6%E6%9D%83%E6%9C%89%E5%90%91%E5%9B%BE%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png"></p>
</li>
<li><p>带权无向图：<img src="/imgs/undirevted-w.png"></p>
<p>  邻接矩阵<img src="/imgs/%E5%B8%A6%E6%9D%83%E6%97%A0%E5%90%91%E5%9B%BE%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png"></p>
</li>
<li><p>带权有向图<img src="/imgs/%E5%B8%A6%E6%9D%83%E6%9C%89%E5%90%91%E5%9B%BE.png"></p>
<p>  邻接矩阵<img src="/imgs/%E5%B8%A6%E6%9D%83%E6%9C%89%E5%90%91%E5%9B%BE%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png"></p>
</li>
<li><p>图的邻接矩阵结构体的定义如下:</p>
<ul>
<li><pre><code class="c">  #define MAXSIZE 100
  //邻接矩阵节点类型 根据需要可设为整型或字符型
  #include &quot;basicnodeType.h&quot;
  
  //邻接矩阵
  struct AMGraph &#123;
      BNODETYPE Vertex[MAXSIZE];
      int Edge[MAXSIZE][MAXSIZE];
      int numV, numE;//顶点、边数量
  &#125;;
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        * 邻接矩阵的特点如下:</span><br><span class="line"></span><br><span class="line">            * 图的邻接矩阵表示唯一</span><br><span class="line">            * 对于含有n个顶点的图,当采用邻接矩阵存储时,无论是有向图还是无向图,也无论边的数量是多少,其存储空间都为O(n²),所以邻接矩阵适合于存储边的数目较多的稠密图</span><br><span class="line">            * 无向图的邻接矩阵数组一定是对称的,因此可以采取压缩存储的思想,在存放邻接矩阵数组时只需存放上(下)三角部分的元素即可</span><br><span class="line">            * 对于无向图,邻接矩阵数组的第$i$ 行或第$i$列非零元素、非$\infty$ 元素的个数正好是顶点$i$的度</span><br><span class="line">            * 对于有向图,邻接矩阵数组的第$i$ 行或第$i$列非零元素、非$\infty$ 元素的个数正好是顶点$i$的出度(或入度)</span><br><span class="line">            * 在邻接矩阵中,判断图中两个顶点之间是否有边或者求两个顶点之间边的权的执行时间为O(1)。所以在需要提取边权值的算法中通常采用邻接矩阵存储结构</span><br><span class="line"></span><br><span class="line">* 邻接表（链式存储）</span><br><span class="line"></span><br><span class="line">    ​	图的邻接表（adjacency list）是一种顺序与链式存储相结合的存储方法。看看下面这个例子</span><br><span class="line"></span><br><span class="line">    ![](imgs/带权有向图.png)</span><br><span class="line"></span><br><span class="line">    ![](imgs/邻接表示意图.png)</span><br><span class="line"></span><br><span class="line">       对邻接表的理解：</span><br><span class="line"></span><br><span class="line">    ​		首先</span><br><span class="line"></span><br><span class="line">* 十字链表（有向图）</span><br><span class="line"></span><br><span class="line">* 邻接多重表（无向图）</span><br><span class="line">### 图的遍历</span><br><span class="line"></span><br><span class="line">* 概念:给定图G,从任意顶点出发,按照某种搜索方法沿着图的边去访问图中的所有顶点,使每个顶点只被访问一次,称这个过程为图的遍历。</span><br><span class="line"></span><br><span class="line">  在图的遍历中：我们需要注意两件事</span><br><span class="line"></span><br><span class="line">   	1. 如果是连通图或者强连通图，那么我们一趟遍历就可以访问完所有的顶点</span><br><span class="line">   	2. 在图中进行遍历是比较复杂的，其一，从初始点到其他顶点可能存在着多条路径，其二，从某顶点开始进行搜索，访问某一顶点后，可能因为存在另一条路径回到该顶点，即回路，如果我们不加限制，那么就会发生重复访问的结果。</span><br><span class="line"></span><br><span class="line">  所以，我们为了避免同一个顶点被重复访问，需要一个机制来记录已访问的顶点，那我们可以很自然的想到利用一个数组来进行记录，我们把它记作标记数组visited，该数组的大小即为顶点的个数，初始状态数组内所有元素均为0，代表还未开始遍历，当顶点$i$被访问过时,数组中的元素visited[$i$]置为1。</span><br><span class="line"></span><br><span class="line">  一般而言，在图中有两大类型的遍历：深度优先遍历和广度优先遍历</span><br><span class="line"></span><br><span class="line">* 深度优先遍历</span><br><span class="line"></span><br><span class="line">    * 如何理解：深度优先遍历见名知意，就是在图的遍历中，从初始顶点开始，我会不断地往更深处去遍历。假设我们从图中的某个初始点$i$ 出发,首先访问该初始点,然后选择一个与顶点$i$相邻且未被访问过的顶点$j$,再以$j$为初始顶点,从它出发进行深度优先遍历,直到图中所有的顶点全部被访问完。从以上描述我们可以看出深度优先遍历其实是一个递归过程。</span><br><span class="line"></span><br><span class="line">        ![image-20230707153852305](imgs/image-20230707153852305.png)</span><br><span class="line"></span><br><span class="line">        例如，上图所示的有向图，我们从顶点1开始进行深度优先遍历，那么访问序列为：1 2 3 4或1 2 4 3</span><br><span class="line"></span><br><span class="line">        *注意：深度优先遍历可能会产生不同的遍历序列，主要是因为我们去选择邻接点时可能存在多个邻接点 ，这就使得深优序列可能不同*</span><br><span class="line"></span><br><span class="line">        ![image-20230707164132462](imgs/image-20230707164132462.png)</span><br><span class="line"></span><br><span class="line">        上图表示从顶点1开始进行深度优先遍历的过程，可以大致分为以下几步：大家一定要好好理解这个过程</span><br><span class="line"></span><br><span class="line">        	初始顶点为1，访问顶点1，将visited数组对应位置置为1，然后寻到邻接点2</span><br><span class="line">        	判断顶点2未被访问，递归调用深度优先算法，以2为“起始点”，访问顶点2，将visited数组对应位置置为1，然后寻到邻接点4</span><br><span class="line">        	判断顶点4未被访问，递归调用深度优先算法，以4为“起始点”，访问顶点4，将visited数组对应位置置为1，然后寻找邻接点</span><br><span class="line">        	未找到邻接点，退出以顶点4为“起始点”的递归，回到以2为“起始点“的递归，继续寻到邻接点3</span><br><span class="line">        	判断顶点3未被访问，递归调用深度优先算法，以3为“起始点”,访问顶点3,将visited数组对应位置置为1,然后寻到邻接点2</span><br><span class="line">        	判断邻接点2已被访问,不再进入递归</span><br><span class="line">        	顶点3无其他未被访问邻接点,退出以顶点3为“起始点”的递归,回到以2为“起始点”的递归,继续寻找邻接点</span><br><span class="line">        	顶点2无其他未被访问邻接点,退出以顶点2为“起始点”的递归,回到以1为“起始点”的递归,继续寻找邻接点</span><br><span class="line">        	顶点1无其他未被访问邻接点,退出以顶点1为“起始点”的递归,程序结束</span><br><span class="line"></span><br><span class="line">    * 将上述过程用代码表示:</span><br><span class="line"></span><br><span class="line">        * 邻接表表示的图</span><br><span class="line"></span><br><span class="line">        ```c</span><br><span class="line">        void DFS(ALGraph* G, int* visited,  int index) &#123;</span><br><span class="line">        	printf(&quot;%c &quot;, G-&gt;adjlist[index].info);//打印传入的节点,即访问</span><br><span class="line">        	visited[index] = 1;//置访问为1</span><br><span class="line">        	for (EdgeNode* w = G-&gt;adjlist[index].firstEdge; w; w = w-&gt;next) &#123;</span><br><span class="line">        		if (!visited[w-&gt;index]) &#123;//未访问</span><br><span class="line">        			DFS(G, visited, w-&gt;index);</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>邻接矩阵表示的图</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(AMGraph* G, <span class="type">int</span>* visited,  <span class="type">int</span> index)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, G-&gt;Vertex[index]);<span class="comment">//打印传入的节点,即访问</span></span><br><span class="line">	visited[index] = <span class="number">1</span>;<span class="comment">//置访问为1</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;numV; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (G-&gt;Edge[index][i] != <span class="number">32767</span> &amp;&amp; !visited[i]) &#123;<span class="comment">//可到达且未访问</span></span><br><span class="line">			DFS(G, visited, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>  可以发现,深度优先算法并不是多么庞杂,但是这个过程涉及到递归,就会不那么容易理解,所以同学一定要踏踏实实地动手模拟这个过程,切忌纸上谈兵</p>
</li>
<li><p>空间复杂度：由于DFS是一个递归算法，递归是需要一个工作栈来辅助工作，最多需要图中所有顶点进栈，所以空间复杂度为O(|V|)</p>
</li>
<li><p>时间复杂度：</p>
<ul>
<li>邻接表：遍历过程的主要操作是对顶点遍历它的邻接点，由于通过访问边表来查找邻接点，所以时间复杂度为O(|E|),访问顶点时间为O(|V|),所以总的时间复杂度为O(|V|+|E|)</li>
<li>邻接矩阵：查找每个顶点的邻接点时间复杂度为O(|V|),对每个顶点都进行查找，所以总的时间复杂度为O($|V|^2$)</li>
</ul>
</li>
</ul>
</li>
<li><p>广度优先遍历</p>
<ul>
<li><p>如何理解:广度优先遍历与深度优先遍历是一个相对的概念,所谓广度,也就是说目之所及皆需纳入考虑范围,从初始顶点$v$开始,将其访问,紧接着依次访问顶点$v$ 的所有未被访问过的邻接点$v_1,v_2,…,v_i$,然后再按照$v_1,v_2,…,v_i$的次序访问每一个顶点的所有未访问过的邻接点,以此类推,知道图中所有和初始点$v$有路径相通的顶点都被访问过为止。</p>
</li>
<li><p><img src="/imgs/image-20230708151143653.png" alt="image-20230708151143653"></p>
<p>  上图所示有向图进行广度优先遍历，我们从顶点1开始，最终遍历序列为 1 2 3 4 5 6或1 3 2 4 5 6</p>
<p>  <em>注意：广度优先遍历可能会产生不同的遍历序列，主要是因为我们去选择邻接点时可能存在多个邻接点 ，这就使得广优序列可能不同</em></p>
</li>
<li><p>广度优先搜索(BFS:Breadth-First-Search):广度优先搜索类似于树的层序遍历算法,需要用到一个队列</p>
</li>
<li><p><img src="/imgs/image-20230712213545110.png" alt="image-20230712213545110"></p>
</li>
<li><p>代码如下</p>
<ul>
<li><p>邻接表存储的图</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(ALGraph* G, <span class="type">int</span>* visited, <span class="type">int</span> v)</span> &#123;<span class="comment">//开始广度遍历</span></span><br><span class="line">	<span class="comment">//声明有关队列的函数</span></span><br><span class="line">	Squeue* <span class="title function_">createQueue</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">	<span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Squeue*)</span>;</span><br><span class="line">	<span class="type">bool</span> <span class="title function_">enQueue</span><span class="params">(Squeue*, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">	<span class="type">bool</span> <span class="title function_">deQueue</span><span class="params">(Squeue*, <span class="type">int</span>*, <span class="type">int</span>)</span>;</span><br><span class="line">	Squeue* sq;</span><br><span class="line">	sq = createQueue(G-&gt;numV);<span class="comment">//创建队列</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, G-&gt;adjlist[v].info);<span class="comment">//访问传进来的顶点</span></span><br><span class="line">	enQueue(sq, v, G-&gt;numV);<span class="comment">//入队</span></span><br><span class="line">	visited[v] = <span class="number">1</span>;<span class="comment">//置为已访问</span></span><br><span class="line">	<span class="keyword">while</span> (!isEmpty(sq)) &#123;<span class="comment">//队列不空，取出队首元素，进行访问</span></span><br><span class="line">		<span class="type">int</span> top;</span><br><span class="line">		deQueue(sq, &amp;top, G-&gt;numV);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, G-&gt;adjlist[top].info);</span><br><span class="line">		<span class="keyword">for</span> (EdgeNode* w = G-&gt;adjlist[top].firstEdge; w; w = w-&gt;next) &#123;<span class="comment">//依次将当前节点的边表入队，和层次遍历一致</span></span><br><span class="line">			<span class="keyword">if</span> (!visited[w-&gt;index]) &#123;</span><br><span class="line">				visited[w-&gt;index] = <span class="number">1</span>;</span><br><span class="line">				enQueue(sq, w-&gt;index, G-&gt;numV);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>邻接矩阵存储的图</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(AMGraph* G, <span class="type">int</span>* visited, <span class="type">int</span> v)</span> &#123;<span class="comment">//开始广度遍历</span></span><br><span class="line">	<span class="comment">//声明有关队列的函数</span></span><br><span class="line">	Squeue* <span class="title function_">createQueue</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">	<span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Squeue*)</span>;</span><br><span class="line">	<span class="type">bool</span> <span class="title function_">enQueue</span><span class="params">(Squeue*, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">	<span class="type">bool</span> <span class="title function_">deQueue</span><span class="params">(Squeue*, <span class="type">int</span>*, <span class="type">int</span>)</span>;</span><br><span class="line">	Squeue* sq;</span><br><span class="line">	sq = createQueue(G-&gt;numV);<span class="comment">//创建队列</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, G-&gt;Vertex[v]);<span class="comment">//访问传进来的顶点</span></span><br><span class="line">	enQueue(sq, v, G-&gt;numV);<span class="comment">//入队</span></span><br><span class="line">	visited[v] = <span class="number">1</span>;<span class="comment">//置为已访问</span></span><br><span class="line">	<span class="keyword">while</span> (!isEmpty(sq)) &#123;<span class="comment">//队列不空，取出队首元素，进行访问</span></span><br><span class="line">		<span class="type">int</span> top;</span><br><span class="line">		deQueue(sq, &amp;top, G-&gt;numV);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;numV;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (G-&gt;Edge[top][i] != <span class="number">32767</span> &amp;&amp; !visited[i]) &#123;<span class="comment">//可到达且未访问</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,G-&gt;Vertex[i]);</span><br><span class="line">				visited[i] = <span class="number">1</span>;</span><br><span class="line">				enQueue(sq,i,G-&gt;numV);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>空间复杂度：BFS需要借助一个队列，n个顶点均需要入队一次，所以最坏情况下n个顶点在队列，那么则需要O(|V|)的空间复杂度。    </p>
</li>
<li><p>时间复杂度：<br>1)邻接表：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，就需要访问这个顶点的所有边，所以时间复杂度为O(|E|)。所以总的时间复杂度为O(|V|+|E|)<br>2)邻接矩阵：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，需要遍历一遍矩阵的一行，所以时间复杂度为O(|V|),所以总的时间复杂度为O($|V|^2$)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="图遍历算法的相关应用"><a href="#图遍历算法的相关应用" class="headerlink" title="图遍历算法的相关应用"></a>图遍历算法的相关应用</h3><h3 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h3><ul>
<li>最小生成树<ul>
<li>普利姆（Prlm）<ul>
<li>①从图中找第一个起始顶点v0，作为生成树的第一个顶点，然后从这个顶点到其他顶点的所有边中选一条权值最小的边。然后把这条边的另一个顶点v和这条边加入到生成树中。</li>
<li>②对剩下的其他所有顶点，分别检查这些顶点与顶点v的权值是否比这些顶点在lowcost数组中对应的权值小，如果更小，则用较小的权值更新lowcost数组。</li>
<li>③从更新后的lowcost数组中继续挑选权值最小而且不在生成树中的边，然后加入到生成树。</li>
<li>④反复执行②③直到所有所有顶点都加入到生成树中。</li>
<li>概要:  <ul>
<li>双重循环，外层循环次数为n-1，内层并列的两个循环次数都是n。故普利姆算法时间复杂度为O(n2)<br>  而且时间复杂度只和n有关，所以适合稠密图</li>
</ul>
</li>
</ul>
</li>
<li>克鲁斯卡尔（Kruskal）<ul>
<li>将图中边按照权值从小到大排列，然后从最小的边开始扫描，设置一个边的集合来记录，如果该边并入不构成回路的话，则将该边并入当前生成树。直到所有的边都检测完为止。</li>
<li>概要:<br>  * <ul>
<li></li>
<li>概要: 克鲁斯卡尔算法操作分为对边的权值排序部分和一个单重for循环，它们是并列关系，由于排序耗费时间大于单重循环，所以克鲁斯卡尔算法的主要时间耗费在排序上。排序和图中边的数量有关系，所以适合稀疏图</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>最短路径<ul>
<li>迪杰斯特拉<ul>
<li>一个源点到其余顶点的最短路径<ul>
<li>该算法设置一个集合S记录已求得的最短路径的顶点，可用一个数组s[]来实现，初始化为0，当s[vi]&#x3D;1时表示将顶点vi放入S中，初始时把源点v0放入S中。此外，在构造过程中还设置了两个辅助数组：<br>  dist[]：记录了从源点v0到其他各顶点当前的最短路径长度，dist[i]初值为arcs[v0][i]。<br>  path[]：path[i]表示从源点到顶点i之间的最短路径的前驱结点，在算法结束时，可根据其值追溯得到源点v0到顶点vi的最短路径。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>假设从顶点0出发，也就是顶点0为源点，集合S最初只包含顶点0，邻接矩阵arcs表示带权有向图，arcs[i][j]表示有向边&lt;i，j&gt;的权值，若不存在有向边&lt;i，j&gt;，则arcs[i][j]为∞。Dijkstra算法的步骤如下：<br>1）初始化：集合S初始为{0}，dist[]的初始值dist[i]&#x3D;arcs[0][i]，i&#x3D;1，2，…，n-1。<br>2）找出dist[]中的最小值dist[j]，将顶点j加入集合S，即修改s[vj]&#x3D;1。<br>3）修改从v0出发到集合V-S上任一顶点vk可达的最短路径长度：如果dist[j] + arcs[j][k]&lt; dist[k]，则令dist[k]&#x3D;dist[j] + arcs[j][k]。另外更新path[k]&#x3D;j(也就是顶点j加入集合之后如果有新的路径使得到顶点k路径变短的话就将到顶点k的路径长度修改成较短的)<br>4）重复2）～3）操作共n-1次，直到所有的顶点都包含在S中。<br>    * 弗洛伊德<br>        * 所有顶点到所有顶点的最短路径<br>            * 算法思想：<br>递推产生一个n阶方阵序列A(−1)，A(0)，…，A(k)，…，A(n−1)<br>其中A(k)[i][j]表示从顶点vi到顶点vj的路径长度，k表示绕行第k个顶点的运算步骤。初始时，对于任意两个顶点vi和vj，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以∞作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点k(k&#x3D;0，1，…，n-1)作为中间顶点。如果增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径<br>    * 非带权图<br>        * 两点之间经过边数最少的路径<br>    * 带权图<br>        * 两点之间经过的边上权值之和最小的路径</p>
<ul>
<li><p>拓扑排序</p>
<ul>
<li><p>AOV</p>
<ul>
<li>如果我们把每个环节看成图中一个顶点，在这样一个有向图中，用顶点表示活动，用弧表示活动之间的优先关系，那么这样的有向图称为AOV网(Activity On Vertex)</li>
</ul>
</li>
<li><p>拓扑排序就是对一个有向图构造拓扑序列的过程，构造会有两种结果：<br>  如果此图全部顶点都被输出了，说明它是不存在回路的AOV网；<br>  如果没有输出全部顶点，则说明这个图存在回路，不是AOV网。</p>
</li>
<li><p>拓扑排序算法：<br>   从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为弧尾的弧。重复这个步骤直到输出图中全部顶点，或者找不到入度为0的顶点为止。</p>
</li>
</ul>
</li>
<li><p>关键路径</p>
<ul>
<li>AOE(Activity On Edge):在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网称为AOE网。</li>
</ul>
</li>
</ul>
<h2 id="第六章：查找"><a href="#第六章：查找" class="headerlink" title="第六章：查找"></a>第六章：查找</h2><h3 id="查找的基本概念和顺序查找"><a href="#查找的基本概念和顺序查找" class="headerlink" title="查找的基本概念和顺序查找"></a>查找的基本概念和顺序查找</h3><ul>
<li>查找定义：在数据集合中寻找满足某种条件的数据元素的过程称为查找</li>
<li>关键字：数据元素中某个可以以唯一标识该元素的数据项</li>
<li>平均查找长度（ASL：Average Search Length）:在查找的过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值</li>
<li>顺序查找(线性查找)，主要用于在线性表中进行查找。从查找表的一端开始，顺序扫描查找表，依次将扫描到的关键字和待查找的值key进行比较。如果相等，则查找成功。如果扫描结束仍然没有发现相等的数据元素，则查找失败。<ul>
<li>1</li>
<li>2</li>
<li>3 </li>
<li>4</li>
<li>时间复杂度为O(n)</li>
</ul>
</li>
</ul>
<h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><ul>
<li>算法思路：<ul>
<li>首先将给定值key与表中中间位置元素的关键字比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分中。然后在缩小的范围内继续进行同样的查找，如此重复直到找到为止，或者确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。</li>
</ul>
</li>
<li>折半查找分析<ul>
<li>折半查找判定树<ul>
<li>对于折半查找，查找的比较次数就是从根结点到该结点经历的结点数</li>
<li>时间复杂度为O(logn)</li>
<li>概要: 具有N个（N&gt;0）结点的完全二叉树的高度为 [log2(N+1)] 或 [log2N] +1。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h3><ul>
<li>分块查找又称为索引顺序查找</li>
<li>分块查找思想：<ul>
<li>①确定待查找值在哪个块（折半查找）</li>
</ul>
</li>
</ul>
<p>②在确定的块中查找待查找值（顺序查找）</p>
<ul>
<li>分块查找分析<ul>
<li>由于分块查找实际是进行两次查找，所以整个算法的平均查找长度是两次查找的平均查找长度之和。<br>即ASL分块&#x3D;ASL折半+ASL顺序<ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><ul>
<li>二叉排序树(Binary Search Tree 也叫二叉搜索树)或者是一棵空树，或者是具有以下性质的二叉树<br>①若左子树不空，则左子树上所有结点的值均小于它的根结点的值。<br>②若右子树不空，则右子树上所有结点的值均大于它的根结点的值。<br>③它的左右子树也是一棵二叉排序树。</li>
<li>算法思想<ul>
<li>由于二叉排序树的特点(左子树&lt;根结点&lt;右子树),所以每次查找一个关键字，需要先和根结点进行比较：<br>如果这个关键字小于根结点的值，则再到这个根结点的左子树进行同样的比较操作一直进行下去直到找到该关键字，表示查找成功，或者是空指针，表示查找失败。<br>如果这个关键字大于根结点的值，则再到这个根结点的右子树进行同样的比较操作一直进行下去直到找到该关键字，表示查找成功，或者是空指针，表示查找失败。<ul>
<li>查找关键字代码<ul>
<li>1 </li>
<li>2</li>
</ul>
</li>
<li>插入关键字代码<ul>
<li>1)空树：直接插入新结点返回成功<br>  2)树不空：检查是否存在关键字重复的结点：<br>  ①存在：返回插入失败<br>  ②不存在：检查根结点的值和待插入关键字值的大小关系递归插入左右子树</li>
<li></li>
</ul>
</li>
<li>构造代码<ul>
<li></li>
</ul>
</li>
<li>删除结点<ul>
<li>①删除的是叶子结点<ul>
<li>方法：直接删去该结点即可</li>
</ul>
</li>
<li>②删除的是仅有左子树或者右子树的结点<ul>
<li>方法：“子承父业”</li>
</ul>
</li>
<li>③删除的是左右子树都有的结点<ul>
<li>仿照②类型，先将一个孩子“继承父业”，另一个孩子“归顺”于这个孩子<br>方法：找到待删除结点的直接前驱或者直接后继结点，用该结点来替换待删除结点，再删除该结点。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>二叉排序树分析<ul>
<li>查找时间复杂度是O(n)</li>
</ul>
</li>
<li>概要: “左小右大”</li>
</ul>
<h3 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a>平衡二叉树(AVL树)</h3><ul>
<li>平衡二叉树(AVL树)是特殊的二叉排序树，特殊的地方在于左右子树的高度之差绝对值不超过1，而且左右子树又是一棵平衡二叉树。</li>
<li>平衡因子<ul>
<li>定义结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是−1、0或1。</li>
</ul>
</li>
<li>平衡调整<ul>
<li><p>平衡二叉树的建立过程和二叉排序树的建立过程是相似的，都是从一棵空树开始陆续插入结点。不同的地方在于对于平衡二叉树的建立过程中，由于插入结点可能会破坏结点的平衡性，所以需要进行平衡调整。</p>
<ul>
<li>LL调整(左孩子的左子树上插入结点导致)<ul>
<li>最小不平衡子树根结点的平衡因子为2&gt;0<br>  它的左孩子结点平衡因子为1&gt;0<br>  两个都大于0，所以直接右旋就可以调整</li>
<li>概要: “正则右旋”</li>
</ul>
</li>
<li>RR调整(右孩子的右子树上插入结点导致)<ul>
<li>最小不平衡子树根结点的平衡因子为-2&lt;0<br>  它的右孩子结点平衡因子为-1&lt;0<br>  两个都小于0，所以直接左旋就可以调整</li>
<li>概要: “负则左旋”</li>
</ul>
</li>
<li>LR调整(左孩子的右子树上插入结点导致)</li>
<li>RL调整(右孩子的左子树上插入结点导致)</li>
<li>概要: 先局部转换为LL或RR，最后进行调整</li>
</ul>
</li>
</ul>
</li>
<li>分析<ul>
<li>含有n个结点平衡二叉树的最大深度为O(log2n)，因此，平衡二叉树的平均查找长度为O(log2n)</li>
</ul>
</li>
</ul>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h3 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h3><ul>
<li>2-3树<ul>
<li>2-3树是一种多路查找树：2和3的意思就是2-3树包含两种结点<ul>
<li>1)2结点包含一个元素和两个孩子(或者没有孩子)。<br>  ①左子树包含的元素小于该结点的元素值，右子树包含的元素大于该结点的元素值<br>  ②2结点要不有两个孩子，要不就没有孩子，不允许有一个孩子</li>
<li>2)3结点包含一大一小两个元素和三个孩子(或者没有孩子)。(两个元素按大小顺序排列好)<br>  ①左子树包含的元素小于该结点较小的元素值，右子树包含的元素大于该结点较大的元素值，中间子树包含的元素介于这两个元素值之间。<br>  ②3结点要不有三个孩子，要不就没有孩子，不允许有一个或两个孩子</li>
<li>3)2-3树所有叶子结点都在同一层次</li>
</ul>
</li>
</ul>
</li>
<li>2-3-4树<ul>
<li>2-3-4树也是一种多路查找树：2和3和4的意思就是2-3-4树包含三种结点<ul>
<li>1)2结点包含一个元素和两个孩子(或者没有孩子)。<br>  ①左子树包含的元素小于该结点的元素值，右子树包含的元素大于该结点的元素值<br>  ②2结点要不有两个孩子，要不就没有孩子，不允许有一个孩子</li>
<li>2)3结点包含一大一小两个元素和三个孩子(或者没有孩子)。<br>  ①左子树包含的元素小于该结点较小的元素值，右子树包含的元素大于该结点较大的元素值，中间子树包含的元素介于这两个元素值之间。<br>  ②3结点要不有三个孩子，要不就没有孩子，不允许有一个或两个孩子</li>
<li>3)4结点包含小中大三个元素和四个孩子(或者没有孩子)。<br>  ①左子树包含的元素小于该结点最小的元素值，第二个子树包含大于最小的元素值小于中间元素值的元素，第三个子树包含大于中间元素值小于最大元素值的元素，右子树包含的元素大于该结点最大的元素值。<br>  ②4结点要不有四个孩子，要不就没有孩子，不允许有一个或两个或三个孩子</li>
<li>4)2-3-4树所有叶子结点都在同一层次</li>
</ul>
</li>
</ul>
</li>
<li>B树<ul>
<li><p>B树也是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例，我们把树中结点最大的孩子数目称为B树的阶。通常记为m。<br>一棵m阶B树或为空树，或为满足如下特性的m叉树：</p>
<ul>
<li>1）树中每个结点至多有m棵子树。（即至多含有m-1个关键字) (“两棵子树指针夹着一个关键字”)</li>
<li>2）若根结点不是终端结点，则至少有两棵子树。(至少一个关键字)</li>
<li>3）除根结点外的所有非叶结点至少有 ⌈m&#x2F;2⌉棵子树。（即至少含有⌈m&#x2F;2⌉-1个关键字）</li>
<li>4）所有非叶结点的结构如下：</li>
<li>5）所有的叶子结点出现在同一层次上，不带信息。(就像是折半查找判断树中查找失败的结点)</li>
</ul>
</li>
<li><p>1.B树的查找操作</p>
<ul>
<li>查找过程：①先让待查找关键字key和结点的中的关键字比较，如果等于其中某个关键字，则查找成功。<br>    ②如果和所有关键字都不相等，则看key处在哪个范围内，然后去对应的指针所指向的子树中查找。<br>        Eg:如果Key比第一个关键字K1还小，则去P0指针所指向的子树中查找，如果比最后一个关键字Kn还大，则去Pn指针所指向的子树中查找。</li>
</ul>
</li>
<li><p>2.B树的插入操作</p>
<ul>
<li>分裂的方法：取这个关键字数组中的中间关键字(⌈n&#x2F;2⌉)作为新的结点，然后其他关键字形成两个结点作为新结点的左右孩子。</li>
</ul>
</li>
<li><p>3.B树的删除操作</p>
<ul>
<li>B树中的删除操作与插入操作类似，但要稍微复杂些，要使得删除后的结点中的关键字个数≥⌈m&#x2F;2⌉-1 ，因此将涉及结点的“合并”问题。由于删除的关键字位置不同，可以分为关键字在终端结点和不在终端结点上两种情况。<ul>
<li><p>1）如果删除的关键字在终端结点上（最底层非叶子结点）：<br>  ①结点内关键字数量大于⌈m&#x2F;2⌉-1 ，这时删除这个关键字不会破坏B树的定义要求。所以直接删除。<br>  ②结点内关键字数量等于⌈m&#x2F;2⌉-1 ，并且其左右兄弟结点中存在关键字数量大于⌈m&#x2F;2⌉-1 的结点，则去兄弟阶段中借关键字。<br>  ③结点内关键字数量等于⌈m&#x2F;2⌉-1 ，并且其左右兄弟结点中不存在关键字数量大于⌈m&#x2F;2⌉-1 的结点，则需要进行结点合并。</p>
</li>
<li><p>2）如果删除的关键字不在终端结点上（最底层非叶子结点）：需要先转换成在终端结点上，再按照在终端结点     上的情况来分别考虑对应的方法。</p>
<ul>
<li>相邻关键字：对于不在终端结点上的关键字,它的相邻关键字是其左子树中值最大的关键字或者右子树中值最小的关键字。</li>
<li>第一种情况：存在关键字数量大于⌈m&#x2F;2⌉-1 的左子树或者右子树，在对应子树上找到该关键字的相邻关键字，然后将相邻关键字替换待删除的关键字。</li>
<li>第二种情况：左右子树的关键字数量均等于⌈m&#x2F;2⌉-1 ，则将这两个左右子树结点合并，然后删除待删除关键字。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>B+树<ul>
<li>B+树是常用于数据库和操作系统的文件系统中的一种用于查找的数据结构</li>
<li>m阶的B+树与m阶的B树的主要差异在于：<br>  1）在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树；而在B树中，具有n个关键字的结点含有(n+1)棵子树。<br>  2）在B+树中，每个结点（非根内部结点）关键字个数n的范围是 ⌈m&#x2F;2⌉≤n≤m（根结点1≤n≤m），在B树中，每个结点（非根内部结点）关键字个数n的范围是⌈m&#x2F;2⌉ -1≤n≤m-1（根结点：1≤n≤m-1）。<br>  3）在B+树中，叶结点包含信息，所有非叶结点仅起到索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。<br>  4）在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点包含的关键字和其他结点包含的关键字是不重复的。</li>
</ul>
</li>
</ul>
<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><ul>
<li><p>散列表：根据给定的关键字来计算出关键字在表中的地址的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。</p>
</li>
<li><p>散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)&#x3D;Addr。</p>
</li>
<li><p>散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为“冲突”，这些发生碰撞的不同关键字称为同义词。</p>
</li>
<li><p>构造散列函数的tips：</p>
<ul>
<li>1）散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。</li>
<li>2）散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间，从而减少冲突的发生。</li>
<li>3）散列函数应尽量简单，能够在较短的时间内就计算出任一关键字对应的散列地址。</li>
</ul>
</li>
<li><p>1.常用Hash函数的构造方法：</p>
<ul>
<li>1.开放定址法：直接取关键字的某个线性函数值为散列地址，散列函数为H(key)&#x3D;a×key+b。式中，a和b是常数。这种方法计算最简单，并且不会产生冲突</li>
<li>2.除留余数法：假定散列表表长为m，取一个不大于m但最接近或等于m的质数p，利用以下公式把关键字转换成散列地址。散列函数为H(key)&#x3D;key % p<br>  除留余数法的关键是选好p，使得每一个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性</li>
<li>3.数字分析法：设关键字是r进制数（如十进制数），而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，则应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合</li>
<li>4.平方取中法：顾名思义，取关键字的平方值的中间几位作为散列地址。具体取多少位要看实际情况而定。这种方法得到的散列地址与关键字的每一位都有关系，使得散列地址分布比较均匀。</li>
<li>5.折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以短一些），然后取这几部分的叠加和作为散列地址，这种方法称为折叠法。关键字位数很多，而且关键字中每一位上数字分布大致均匀时，可以采用折叠法得到散列地址。</li>
</ul>
</li>
<li><p>2.常用Hash函数的冲突处理办法：</p>
<ul>
<li>1.开放定址法：将产生冲突的Hash地址作为自变量，通过某种冲突解决函数得到一个新的空闲的Hash地址。<ul>
<li>1）线性探测法：冲突发生时，顺序查看表中下一个单元（当探测到表尾地址m-1时，下一个探测地址是表首地址0），直到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。</li>
<li>2）平方探测法：设发生冲突的地址为d,平方探测法得到的新的地址序列为d+12，d-12，d+22，d-22……<br>  平方探测法是一种较好的处理冲突的方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。</li>
<li>3）再散列法：又称为双散列法。需要使用两个散列函数，当通过第一个散列函数H(Key)得到的地址发生冲突时，则利用第二个散列函数Hash2(Key)计算该关键字的地址增量。</li>
<li>4）伪随机序列法：当发生地址冲突时，地址增量为伪随机数序列，称为伪随机序列法。</li>
</ul>
</li>
<li>2.拉链法：对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。拉链法适用于经常进行插入和删除的情况。</li>
<li>3.散列表的查找过程：类似于构造散列表，给定一个关键字Key。<br>先根据散列函数计算出其散列地址。然后检查散列地址位置有没有关键字。<br>   1)如果没有，表明该关键字不存在，返回查找失败。<br>   2)如果有，则检查该记录是否等于关键字。<br>       ①如果等于关键字，返回查找成功。<br>       ②如果不等于，则按照给定的冲突处理办法来计算下一个散列地址，再用该地址去执行上述过程。</li>
<li>4.散列表的查找性能：和装填因子有关。<ul>
<li></li>
<li>α越大，表示装填的记录越“满”，发生冲突的可能性就越大，反之发生冲突的可能性越小</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第七章：排序"><a href="#第七章：排序" class="headerlink" title="第七章：排序"></a>第七章：排序</h2><h3 id="排序的基本知识"><a href="#排序的基本知识" class="headerlink" title="排序的基本知识"></a>排序的基本知识</h3><ul>
<li>定义：排序就是将原本无序的序列重新排列成有序的序列。</li>
<li>排序的稳定性<ul>
<li>如果待排序表中有两个元素Ri、Rj，其对应的关键字keyi&#x3D;keyj，且在排序前Ri在Rj前面，如果使用某一排序算法排序后，Ri仍然在Rj的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。</li>
</ul>
</li>
</ul>
<h3 id="插入类排序"><a href="#插入类排序" class="headerlink" title="插入类排序"></a>插入类排序</h3><ul>
<li>直接插入排序<ul>
<li>直接插入排序：首先以一个元素为有序的序列，然后将后面的元素依次插入到有序的序列中合适的位置直到所有元素都插入有序序列。</li>
<li>时间复杂度为O(n)</li>
<li>直接插入排序是稳定性是稳定的。</li>
</ul>
</li>
<li>折半插入排序<ul>
<li>折半插入排序将比较和移动这两个操作分离出来，也就是先利用折半查找找到插入的位置，然后一次性移动元素，再插入该元素。</li>
<li>折半插入排序的时间复杂度为O(n^2)</li>
<li>稳定性：和直接插入排序稳定性相同，是稳定的。</li>
</ul>
</li>
<li>希尔排序<ul>
<li>希尔排序的基本思想：希尔排序本质上还是插入排序，只不过是把待排序序列分成几个子序列，再分别对这几个子序列进行直接插入排序。<ul>
<li>①先以增量5来分割序列，也就是下标为0,5,10,15…的关键字分成一组，下标为1,6,11,16..分成一组,然后对这些组分别进行直接插入排序，这就完成了一轮希尔排序。</li>
<li>②缩小增量(d1&#x3D;n&#x2F;2，di+1&#x3D; [di&#x2F;2]，比如10个数据序列，第一次增量d1&#x3D;10&#x2F;2&#x3D;5,第二次增量d2&#x3D; [d1&#x2F;2]&#x3D; [5&#x2F;2]&#x3D;2,并且最后一个增量等于1),所以第二轮以增量为2进行类似的排序过程。</li>
<li>③接下来的第三轮，第四轮…都是类似的过程，直到最后一轮以增量为1。此时就是前面所说的直接插入排序。</li>
<li>概要:</li>
</ul>
</li>
<li>时间复杂度：…  希尔排序的时间复杂度约为O(n^1.3)    在最坏情况下希尔排序的时间复杂度为O(n^2)</li>
<li>空间复杂度：希尔排序的空间复杂度为O(1)</li>
<li>稳定性：不稳定，由于不同的增量可能就会把相等的关键字划分到两个直接插入排序中进行排序， 可能就会造成相对顺序变化。</li>
</ul>
</li>
</ul>
<h3 id="交换类排序"><a href="#交换类排序" class="headerlink" title="交换类排序"></a>交换类排序</h3><ul>
<li>冒泡排序<ul>
<li>假设待排序表长为n，从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]&gt;A[i]），则交换它们，直到序列比较完。我们称它为一趟冒泡，结果将最小的元素交换到待排序列的第一个位置。下一趟冒泡时，前一趟确定的最小元素不再参与比较，待排序列减少一个元素，每趟冒泡的结果把序列中的最小元素放到了序列的最终位置，……，这样最多做n-1趟冒泡就能把所有元素排好序。</li>
<li>空间复杂度：交换时开辟了存储空间来存储中间变量，所以空间复杂度为O(1)</li>
<li>时间复杂度</li>
<li>稳定性：当两个关键字相等，if判断条件不成立，所以不会发生数据移动。所以是稳定的。</li>
</ul>
</li>
<li>快速排序<ul>
<li>快速排序是一种基于分治法的排序方法。<br>每一趟快排选择序列中任一个元素作为枢轴(pivot)(通常选第一个元素)，将序列中比枢轴小的元素都移到枢轴前边，比枢轴大的元素都移到枢轴后边。<ul>
<li>1</li>
<li>2</li>
</ul>
</li>
<li>时间复杂度：<br>  最好情况下时间复杂度为O(nlogn) ,待排序序列越无序，算法效率越高。<br>   最坏情况下时间复杂度为O(n^2)，待排序序列越有序，算法效率越低。</li>
<li>空间复杂度：<br>  由于快速排序是递归的，需要借助一个递归工作栈来保存每一层递归调用的必要信息，其容量应与递归调用的最大深度一致。<br>  最好情况下为 ⌈log2(n+1)⌉(每次partition都很均匀)递归树的深度O(logn)<br>  最坏情况下，因为要进行n-1次递归调用，所以栈的深度为O(n)；</li>
<li>稳定性：快速排序是不稳定的，是因为存在交换关键字。</li>
</ul>
</li>
</ul>
<h3 id="选择类排序"><a href="#选择类排序" class="headerlink" title="选择类排序"></a>选择类排序</h3><ul>
<li>简单选择排序<ul>
<li></li>
<li>空间复杂度：需要额外的存储空间仅为交换元素时借助的中间变量，所以空间复杂度是O(1)</li>
<li>时间复杂度：<br>关键操作在于交换元素操作，整个算法由双重循环组成，外层循环从0到n-2一共n-2+1&#x3D;n-1次，<br>对于第i层外层循环，内层循环执行n-1-(i+1)+1&#x3D;n-i-1次。<br>            当i&#x3D;0,内层循环执行n-1次，当i&#x3D;n-2,内层循环执行1次，所以是一个等差数列求和,一共为(1+n-1)(n-1)&#x2F;2&#x3D;n(n-1)&#x2F;2 ,所以时间复杂度为O(n^2)</li>
<li>稳定性：不稳定   原因就在于交换部分会打破相对顺序</li>
</ul>
</li>
<li>堆排序<ul>
<li><p>什么是堆？</p>
<ul>
<li>堆是一棵完全二叉树，而且满足任何一个非叶结点的值都不大于(或不小于)其左右孩子结点的值。<ul>
<li>如果是每个结点的值都不小于它的左右孩子结点的值，则称为大顶堆。</li>
<li>如果是每个结点的值都不大于它的左右孩子结点的值，则称为小顶堆。</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是堆排序？</p>
<ul>
<li>我们知道对于一个堆来说，它的根结点是整个堆中所有结点的值的最大值(大顶堆)或者最小值(小顶堆)。所以堆排序的思想就是每次将无序序列调节成一个堆，然后从堆中选择堆顶元素的值，这个值加入有序序列，无序序列减少一个，再反复调节无序序列，直到所有关键字都加入到有序序列。<ul>
<li></li>
<li></li>
</ul>
</li>
<li>时间复杂度：<br> 堆排序的总时间可以分为①建堆部分+②n-1次向下调整堆</li>
</ul>
<p> 堆排序的时间复杂度为O(n)+O(nlog2n)&#x3D;O(nlog2n)</p>
<ul>
<li>堆排序不稳定</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul>
<li>假定待排序表含有n个记录，则可以看成是n个有序的子表，每个子表长度为1，然后两两归并，得到 ⌈n&#x2F;2⌉个长度为2或1的有序表；再两两归并，……如此重复，直到合并成一个长度为n的有序表为止，这种排序方法称为2-路归并排序。<ul>
<li></li>
<li></li>
</ul>
</li>
<li>例如：49 38 65 97 76 13 27<ul>
<li>①首先将整个序列的每个关键字看成一个单独的有序的子序列</li>
<li>②两两归并，49和38归并成{38 49} ，65和97归并成{65 97}，76和13归并成{13 76}，27没有归并对象</li>
<li>③两两归并，{38 49}和{65 97}归并成{38 49 65 97}，{13,76}和27归并成{13 27 76}</li>
<li>④两两归并，{38 49 65 97}和{13 27 76}归并成{13 27 38 49 65 76 97}</li>
</ul>
</li>
<li>时间复杂度：O(nlog2n)</li>
<li>空间复杂度:因为需要将这个待排序序列转存到一个数组，所以需要额外开辟大小为n的存储空间，即空间复杂度为O(n)</li>
<li>稳定性：稳定</li>
</ul>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><ul>
<li>基数排序(也叫桶排序)是一种很特别的排序方法，它不是基于比较进行排序的，而是采用多关键字排序思想（即基于关键字各位的大小进行排序的），借助“分配”和“收集”两种操作对单逻辑关键字进行排序。基数排序又分为最高位优先（MSD）排序和最低位优先（LSD）排序。</li>
<li>例子：53, 3, 542, 748, 14, 214, 154, 63, 616<ul>
<li>补充位数：053, 003, 542, 748, 014, 214, 154, 063, 616</li>
<li>桶实际是一个队列，先进先出(从桶的上面进，下面出)</li>
<li>关键字数量为n,关键字的位数为d,比如748 d&#x3D;3，r为关键字的基的个数，就是组成关键字的数据的种类，比如十进制数字一共有0至9一共10个数字，即r&#x3D;10</li>
</ul>
</li>
<li>空间复杂度：需要开辟关键字基的个数个队列，所以空间复杂度为O(r)</li>
<li>时间复杂度：需要进行关键字位数d次”分配”和”收集”，一次”分配”需要将n个关键字放进各个队列中，一次”收集”需要将r个桶都收集一遍。所以一次”分配”和一次”收集”时间复杂度为O(n+r)。d次就需要O(d(n+r))的时间复杂度。</li>
<li>稳定性：由于是队列，先进先出的性质，所以在分配的时候是按照先后顺序分配，也就是稳定的，所以收集的时候也是保持稳定的。即基数排序是稳定的排序算法。</li>
</ul>
<h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3><ul>
<li>需要将待排序的记录存储在外存上，排序时再把数据一部分一部分的调入内存进行排序。在排序过程中需要多次进行内存和外存之间的交换，对外存文件中的记录进行排序后的结果仍然被放到原有文件中。这种排序的方法就叫做外部排序。</li>
<li>如何得到初始的归并段<ul>
<li>置换选择排序：解决排序段放入内存的问题</li>
</ul>
</li>
<li>如何减少多个归并段的归并次数<ul>
<li>最佳归并树：最少的归并次数（I&#x2F;O次数）</li>
</ul>
</li>
<li>如何每次m路归并快速得到最小的关键字<ul>
<li>败者树：减少比较次数</li>
</ul>
</li>
<li>概要: 内存容量无法容纳大量数据</li>
</ul>
<h2 id="二叉树与树与森林"><a href="#二叉树与树与森林" class="headerlink" title="二叉树与树与森林"></a>二叉树与树与森林</h2><h3 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h3><ul>
<li>如何将一棵树转化成二叉树？<ul>
<li>树的孩子兄弟表示法与二叉树的二叉链表表示法都是用到两个指针<ul>
<li>将孩子兄弟表示法理解成二叉链表</li>
</ul>
</li>
<li>树转换成二叉树的手动模拟方法：<ul>
<li>①将同一结点的各个孩子用线串连起来</li>
<li>②将每个结点的子树分支，从左往右，除了第一个以外全部删除</li>
<li>概要: 例子</li>
</ul>
</li>
</ul>
</li>
<li>如何将一棵二叉树转化成树？<ul>
<li>二叉树转换成树的手动模拟方法：<ul>
<li>①将二叉树从上到下分层，并调节成水平方向。<br>  (分层方法：每遇到左孩子则为一层)</li>
<li>②找到每一层的双亲结点，方法为它的上一层相连的那个结点就是双亲结点。<br>  例如bcd这一层，与它相连的上一层结点即为a,所以bcd这三个结点的双亲结点都是a.</li>
<li>③将每一层结点和其双亲结点相连，同时删除该双亲结点各个孩子结点之间的联系。</li>
<li>概要: 例子</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="森林与二叉树"><a href="#森林与二叉树" class="headerlink" title="森林与二叉树"></a>森林与二叉树</h3><ul>
<li>森林：森林是m（m≥0）棵互不相交的树的集合</li>
<li>如何将森林转换成二叉树？<ul>
<li>森林转换成树的手动模拟方法：<ul>
<li>①将森林中每棵树都转换成二叉树</li>
<li>②将第二棵树作为第一棵树的根结点的右子树，将第三棵树作为第二棵树的根结点的右子树..依次类推</li>
<li>概要: 例子</li>
</ul>
</li>
</ul>
</li>
<li>如何将二叉树转换成森林？<ul>
<li>二叉树转换成森林的手动模拟方法：<ul>
<li>反复断开二叉树根结点的右孩子的右子树指针，直到不存在根结点有右孩子的二叉树为止。</li>
<li>概要: 例子</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h3><ul>
<li>先序：先访问根结点，再访问根结点的每棵子树。           访问子树也是按照先序的要求</li>
<li>后序：先访问根结点的每棵子树，再访问根结点。           访问子树也是按照先序的要求</li>
<li>树的先序遍历等于它对应二叉树的先序遍历，后序遍历等于它对应的二叉树的中序遍历</li>
<li>概要: 例子</li>
</ul>
<p><img src="https://github.com/SSHeRun/CS-Xmind-Note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="picture"> </p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">北街学长</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%B2%E4%B9%89/">http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%B2%E4%B9%89/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">北街学长</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%B2%E4%B9%89/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-12-23
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            北街学长
                            
                        </span>
                    </div>
                </div>

                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                本篇&nbsp;<i class="far fa-dot-circle"></i>
            </div>
            <div class="card">
                <a href="/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%B2%E4%B9%89/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-12-23
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            北街学长
                            
                        </span>
                    </div>
                </div>

                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023</span>
            
            <a href="/about" target="_blank">北街学长</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2023";
                        var startMonth = "12";
                        var startDate = "23";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/lhyhyl" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:18181378011@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=973086561" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 973086561" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
